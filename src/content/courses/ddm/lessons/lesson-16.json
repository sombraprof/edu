{
  "formatVersion": "md3.lesson.v1",
  "id": "lesson-16",
  "title": "Aula 16: Unidade III – Estruturando o RoomDatabase e Migrações",
  "slug": "roomdatabase-e-migracoes",
  "summary": "Aprofunda a construção da classe RoomDatabase, configuração de provedores, migrações e testes instrumentados para garantir persistência local confiável, conectando teoria e prática com exemplos comentados.",
  "objective": "Construir uma base Room robusta com provedores de dependência, migrações controladas e verificações automatizadas, detalhando decisões de projeto para alunos que estão estruturando o primeiro banco local.",
  "objectives": [
    "Configurar a classe RoomDatabase com padrão singleton seguro.",
    "Criar migrações básicas entre versões do banco.",
    "Integrar o Room com corrotinas e Flow para leitura reativa.",
    "Validar a persistência com testes instrumentados simples."
  ],
  "competencies": [
    "Arquitetura de dados em Android",
    "Boas práticas de persistência local",
    "Garantia de qualidade em banco de dados mobile"
  ],
  "skills": [
    "Implementar RoomDatabase com instância compartilhada.",
    "Escrever classes Migration controlando alterações de schema.",
    "Configurar testes instrumentados para operações de banco.",
    "Utilizar Flow/LiveData para observar mudanças nos dados."
  ],
  "outcomes": [
    "Entende o ciclo de vida da base Room dentro do aplicativo.",
    "Entrega uma migração funcional entre versões 1 e 2 do schema.",
    "Documenta o setup do banco e publica evidências no Moodle."
  ],
  "prerequisites": [
    "Aula 14 – Introdução ao Room: Entities e DAO.",
    "Familiaridade com corrotinas em Kotlin."
  ],
  "tags": ["android", "room", "migracoes", "persistencia"],
  "duration": 120,
  "modality": "in-person",
  "resources": [
    {
      "label": "Room database reference",
      "url": "https://developer.android.com/reference/androidx/room/RoomDatabase",
      "type": "reference"
    },
    {
      "label": "Guide to Room migrations",
      "url": "https://developer.android.com/training/data-storage/room/migrating-db-versions",
      "type": "article"
    },
    {
      "label": "Testing Room databases",
      "url": "https://developer.android.com/training/data-storage/room/testing-db",
      "type": "article"
    }
  ],
  "bibliography": [
    "ANDROID DEVELOPERS. Migrate Room databases. 2024.",
    "FARQUHAR, I. et al. Android Programming: The Big Nerd Ranch Guide. 5. ed. 2023.",
    "GOYAL, M. Android Room Database. Apress, 2023."
  ],
  "assessment": {
    "type": "formative",
    "description": "Revisão por pares do módulo RoomDatabase com checklist de migrações e testes automatizados."
  },
  "content": [
    {
      "type": "videos",
      "title": "Referências em vídeo – Unidade III",
      "videos": [
        {
          "url": "https://www.youtube.com/watch?v=lwAvI3WDXBY",
          "title": "Room: arquitetando persistência local",
          "caption": "Sessão técnica do Google I/O apresentando o Room. Créditos: Android Developers (Google, 2017)."
        },
        {
          "url": "https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9mxIBd0DRw9gwXuQshgEts",
          "title": "Android Jetpack Architecture Components",
          "caption": "Playlist institucional sobre persistência, ViewModel e LiveData. Créditos: Android Developers (Google, 2024)."
        }
      ]
    },
    {
      "type": "flightPlan",
      "title": "Plano de voo da aula",
      "items": [
        "Recapitular componentes Room: Entity, DAO e Database com mapa mental coletivo.",
        "Desenhar o ciclo de inicialização da RoomDatabase destacando Application, Providers e Injeção de Dependências.",
        "Configurar instância singleton com Room.databaseBuilder() explicitando parâmetros obrigatórios e opcionais.",
        "Criar MIGRATION_1_2 adicionando nova coluna e avaliando impacto em dados legados.",
        "Projeto prático: preparar módulo de persistência reutilizável com package data bem documentado.",
        "Testes instrumentados: validar inserção/leitura e erros comuns (como schema desatualizado).",
        "TED e avisos Moodle para consolidação."
      ]
    },
    {
      "type": "contentBlock",
      "title": "Construindo a classe RoomDatabase",
      "content": [
        {
          "type": "paragraph",
          "text": "Mostramos o padrão recomendado para expor a instância da base usando o contexto de aplicação e evitando vazamentos. Antes do código, reforçamos que RoomDatabase deve ser inicializada uma única vez e reaproveitada por toda a aplicação para evitar corrupção de dados e uso excessivo de memória."
        },
        {
          "type": "paragraph",
          "text": "Explique aos alunos que o padrão singleton seguro em Kotlin utiliza a anotação @Volatile e o bloco synchronized. Esses elementos impedem que duas threads criem instâncias diferentes em cenários de inicialização simultânea (por exemplo, quando o app é restaurado e uma ViewModel demanda dados rapidamente)."
        },
        {
          "type": "code",
          "language": "kotlin",
          "code": "@Database(entities = [Produto::class], version = 2, exportSchema = true)\nabstract class AppDatabase : RoomDatabase() {\n    // Exponha o DAO como função abstrata para que Room gere a implementação automaticamente\n    abstract fun produtoDao(): ProdutoDao\n\n    companion object {\n        @Volatile\n        private var INSTANCE: AppDatabase? = null\n\n        fun getInstance(context: Context): AppDatabase {\n            // O operador Elvis (?:) tenta reutilizar a instância; se for nula, entra no bloco synchronized\n            return INSTANCE ?: synchronized(this) {\n                val instance = Room.databaseBuilder(\n                    context.applicationContext,\n                    AppDatabase::class.java,\n                    \"catalogo.db\" // Nome físico do arquivo SQLite\n                )\n                    // Registrar migrações garante que usuários antigos não percam dados ao atualizar o app\n                    .addMigrations(MIGRATION_1_2)\n                    // Em ambientes de laboratório, o fallback ajuda a evitar crashes quando o schema retrocede\n                    .fallbackToDestructiveMigrationOnDowngrade()\n                    .build()\n                INSTANCE = instance\n                instance\n            }\n        }\n    }\n}\n\n// Referência: ANDROID DEVELOPERS (2024)"
        },
        {
          "type": "callout",
          "variant": "info",
          "title": "Boas práticas",
          "content": [
            {
              "type": "list",
              "ordered": false,
              "items": [
                "Prefira applicationContext para evitar leaks.",
                "Documente as versões do schema no README do projeto.",
                "ExportSchema=true facilita auditorias e diffs de migração."
              ]
            },
            {
              "type": "paragraph",
              "text": "Discuta com a turma quais estratégias de injeção (Hilt, Koin ou manual) combinam melhor com projetos acadêmicos e quais adaptações seriam necessárias no código exemplo."
            }
          ]
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "Projeto prático: módulo de persistência reutilizável",
      "content": [
        {
          "type": "paragraph",
          "text": "Em trios, refatoramos o app catálogo criando um pacote data com AppDatabase, DAOs e providers de dependência (Hilt/Koin opcional)."
        },
        {
          "type": "subBlock",
          "title": "Entregáveis da aula",
          "items": [
            "Classe AppDatabase configurada.",
            "Arquivo de provider (object ou módulo DI) retornando o DAO.",
            "Teste instrumentado que insere e recupera um Produto.",
            "Documento explicando as migrações registradas até o momento."
          ]
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "Migrações em prática",
      "content": [
        {
          "type": "paragraph",
          "text": "Criamos uma nova coluna \"favorito\" na tabela Produto para ilustrar migrações incrementais. Aproveite para contextualizar que migrações são scripts versionados: cada alteração precisa considerar dados antigos e conversões necessárias."
        },
        {
          "type": "paragraph",
          "text": "Durante a aula, compare uma migração bem-sucedida com um cenário problemático (por exemplo, esquecer DEFAULT em colunas obrigatórias), mostrando como testes instrumentados detectam esses erros antes de chegar ao usuário final."
        },
        {
          "type": "code",
          "language": "kotlin",
          "code": "val MIGRATION_1_2 = object : Migration(1, 2) {\n    override fun migrate(database: SupportSQLiteDatabase) {\n        // ALTER TABLE adiciona a coluna sem remover dados existentes\n        database.execSQL(\n            \"ALTER TABLE produto ADD COLUMN favorito INTEGER NOT NULL DEFAULT 0\"\n        )\n        // DEFAULT 0 garante compatibilidade com usuários que já tinham registros salvos\n    }\n}\n\n// Referência: ANDROID DEVELOPERS (2024)"
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "TED 16 – Documentação técnica da base de dados",
      "content": [
        {
          "type": "paragraph",
          "text": "Escreva um documento de 1 página descrevendo o fluxo de inicialização do RoomDatabase e as migrações criadas. Inclua captura do teste instrumentado rodando com sucesso e explique qual caso de teste foi automatizado."
        },
        {
          "type": "list",
          "ordered": true,
          "items": [
            "Detalhar responsabilidades de cada classe do pacote data (entities, dao, database, repositories).",
            "Explicar como o app garante instância única usando getInstance() e injeção de dependência.",
            "Registrar próximos passos para migrações 2_3 e 3_4 incluindo riscos e estratégias de rollback."
          ]
        }
      ]
    },
    {
      "type": "callout",
      "variant": "warning",
      "title": "Avisos Moodle",
      "content": [
        {
          "type": "paragraph",
          "text": "Submeta o PDF da documentação, o script SQL da migração e o relatório de testes em Moodle > Unidade III > Aula 16 até 23h59 de amanhã."
        },
        {
          "type": "paragraph",
          "text": "Atualize o repositório no Moodle Classroom com a branch \"feature/roomdatabase\" antes da aula 17."
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "Exemplo de código comentado",
      "content": [
        {
          "type": "paragraph",
          "text": "O exemplo evidencia como estruturar entidades e DAOs coerentes com o conteúdo de Estruturando o RoomDatabase e Migrações. Comentários adicionais sinalizam boas práticas de modelagem e integração com Flow."
        },
        {
          "type": "code",
          "language": "kotlin",
          "code": "@Entity(tableName = \"registros\")\ndata class Registro(\n    @PrimaryKey(autoGenerate = true) val id: Long = 0,\n    val titulo: String, // título amigável exibido na UI\n    val atualizadoEm: Long // timestamp usado para ordenação e sincronização\n)\n\n@Dao\ninterface RegistroDao {\n    @Query(\"SELECT * FROM registros ORDER BY atualizadoEm DESC\")\n    fun listar(): Flow<List<Registro>> // Flow facilita atualização reativa na camada de apresentação\n}\n// Referência: ANDROID DEVELOPERS (2024)"
        },
        {
          "type": "paragraph",
          "text": "Observe que a consulta utiliza Flow para aderir às recomendações de ANDROID DEVELOPERS (2024). Aproveite para debater por que Flow e corrotinas favorecem escrita de testes instrumentados e unitários, ao permitir controle preciso do dispatcher."
        },
        {
          "type": "callout",
          "variant": "academic",
          "title": "Fundamentação bibliográfica",
          "content": [
            {
              "type": "paragraph",
              "text": "ANDROID DEVELOPERS. Migrate Room databases. 2024."
            }
          ]
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "Leitura complementar e estudos de caso",
      "content": [
        {
          "type": "paragraph",
          "text": "Reforce os conceitos de Estruturando o RoomDatabase e Migrações relacionando SharedPreferences, Room e estratégias de migração. Sugira uma roda de conversa para comparar quando preferir cache leve (SharedPreferences/DataStore) versus banco relacional."
        },
        {
          "type": "list",
          "items": [
            "Releia: ANDROID DEVELOPERS. Migrate Room databases. 2024.",
            "Conecte com o estudo: FARQUHAR, I. et al. Android Programming: The Big Nerd Ranch Guide. 5. ed. 2023."
          ]
        },
        {
          "type": "paragraph",
          "text": "Descreva um caso de uso real do seu projeto que se beneficie de camadas de persistência bem definidas. Incentive os grupos a compartilharem no fórum Moodle para feedback coletivo."
        },
        {
          "type": "blockquote",
          "text": "FARQUHAR, I. et al. Android Programming: The Big Nerd Ranch Guide. 5. ed. 2023."
        }
      ]
    }
  ],
  "metadata": {
    "updatedAt": "2025-10-04T00:00:00.000Z",
    "owners": ["Equipe de Conteúdo"]
  }
}
