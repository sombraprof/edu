{
  "id": "lesson-13",
  "title": "Aula 13: Unidade III – Persistência com SharedPreferences",
  "objective": "Implementar persistência local de dados leves com SharedPreferences, garantindo leitura e escrita seguras alinhadas ao ciclo de vida do app.",
  "content": [
    {
      "type": "flightPlan",
      "title": "Plano de voo da aula",
      "items": [
        "Contextualização: Diferenciar estado temporário (Bundle) e persistência de dados.",
        "O que são SharedPreferences: Entender a metáfora de gaveta de configurações do app.",
        "Como usar: Construir leitura e escrita passo a passo.",
        "Atividade guiada: Implementar um app que lembra o nome da pessoa usuária.",
        "Relevância profissional: Identificar cenários reais de uso.",
        "Tarefa (TED): Consolidar com um exercício prático acompanhado de evidências."
      ]
    },
    {
      "type": "contentBlock",
      "title": "Estado temporário vs. persistência de dados",
      "content": [
        {
          "type": "paragraph",
          "text": "Na Aula 8 utilizamos Bundle para salvar estado em mudanças de configuração. Ele é temporário: ao fechar o app, as informações somem."
        },
        {
          "type": "paragraph",
          "text": "A Unidade III inaugura a persistência local moderna. Precisamos de dados que sobrevivam ao fechamento do aplicativo; o primeiro recurso é SharedPreferences."
        },
        {
          "type": "callout",
          "variant": "info",
          "title": "Analogia rápida",
          "content": [
            {
              "type": "paragraph",
              "text": "Pense no Bundle como um post-it grudado na tela: útil, porém descartável. SharedPreferences funciona como um caderno guardado na gaveta, sempre disponível quando precisamos consultar uma informação salva."
            }
          ]
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "O que são SharedPreferences?",
      "content": [
        {
          "type": "paragraph",
          "text": "API do Android para armazenar pequenas coleções no formato chave-valor em um arquivo XML privado do app."
        },
        {
          "type": "subBlock",
          "title": "Quando usar",
          "items": [
            "- Preferências do usuário: modo escuro, idioma ou notificações ativas.\n- Dados simples: lembrar o último nome ou e-mail utilizado.\n- Estados rápidos de jogo: pontuação máxima ou nível desbloqueado."
          ]
        },
        {
          "type": "callout",
          "variant": "warning",
          "title": "Quando não usar",
          "content": [
            {
              "type": "paragraph",
              "text": "Evite SharedPreferences para dados complexos, coleções grandes ou informações sensíveis. Para listas robustas use o Room; para segredos utilize cofres seguros ou criptografia."
            }
          ]
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "Como usar SharedPreferences: leitura e escrita",
      "content": [
        {
          "type": "paragraph",
          "text": "O fluxo envolve três passos principais: obter uma instância, escrever valores e ler de volta com um padrão."
        },
        {
          "type": "paragraph",
          "text": "Passo 1 — Obter uma instância. Escolha um nome de arquivo e chame getSharedPreferences()."
        },
        {
          "type": "code",
          "language": "kotlin",
          "code": "val sharedPreferences = getSharedPreferences(\"PREFS_DO_MEU_APP\", MODE_PRIVATE)"
        },
        {
          "type": "paragraph",
          "text": "Passo 2 — Escrever dados. Abra o editor, aplique os métodos put... e finalize com apply()."
        },
        {
          "type": "code",
          "language": "kotlin",
          "code": "val editor = sharedPreferences.edit()\neditor.putString(\"CHAVE_NOME_USUARIO\", \"Tiago Sombra\")\neditor.putBoolean(\"CHAVE_MODO_NOTURNO\", true)\neditor.apply()"
        },
        {
          "type": "callout",
          "variant": "info",
          "title": "apply() ou commit()?",
          "content": [
            {
              "type": "paragraph",
              "text": "Prefira apply(): a escrita ocorre em segundo plano e não bloqueia a thread principal. commit() é síncrono e só deve ser usado quando for realmente necessário garantir o retorno imediato."
            }
          ]
        },
        {
          "type": "paragraph",
          "text": "Passo 3 — Ler dados. Utilize os métodos get... informando a chave e um valor padrão."
        },
        {
          "type": "code",
          "language": "kotlin",
          "code": "val nomeSalvo = sharedPreferences.getString(\"CHAVE_NOME_USUARIO\", \"Usuário\")\nval modoNoturnoAtivo = sharedPreferences.getBoolean(\"CHAVE_MODO_NOTURNO\", false)"
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "Atividade prática: app Lembrar de Mim",
      "content": [
        {
          "type": "paragraph",
          "text": "Vamos construir o app demonstrado em aula: um campo para digitar o nome, um botão para salvar e uma saudação automática ao reabrir."
        },
        {
          "type": "paragraph",
          "text": "Passo 1 — Layout. Garanta que o arquivo activity_main.xml tenha componentes para entrada, saudação e botão."
        },
        {
          "type": "code",
          "language": "xml",
          "code": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout ... android:orientation=\"vertical\" android:padding=\"16dp\">\n    <TextView\n        android:id=\"@+id/textViewSaudacao\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:textSize=\"20sp\"\n        tools:text=\"Olá, Visitante!\" />\n    <EditText\n        android:id=\"@+id/editTextNome\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginTop=\"24dp\"\n        android:hint=\"Qual o seu nome?\" />\n    <Button\n        android:id=\"@+id/buttonSalvar\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginTop=\"16dp\"\n        android:text=\"Salvar Nome\" />\n</LinearLayout>"
        },
        {
          "type": "paragraph",
          "text": "Passo 2 — Lógica. Crie a Activity para salvar o nome, atualizar a saudação e limpar o campo."
        },
        {
          "type": "code",
          "language": "kotlin",
          "code": "package br.com.unichristus.ads.sharedprefs\n\nimport android.content.SharedPreferences\nimport androidx.appcompat.app.AppCompatActivity\nimport android.os.Bundle\nimport android.widget.Button\nimport android.widget.EditText\nimport android.widget.TextView\n\nclass MainActivity : AppCompatActivity() {\n\n    private lateinit var textViewSaudacao: TextView\n    private lateinit var editTextNome: EditText\n    private lateinit var buttonSalvar: Button\n    private lateinit var sharedPreferences: SharedPreferences\n\n    companion object {\n        private const val ARQUIVO_PREFS = \"AppPrefs\"\n        private const val CHAVE_NOME = \"NOME_USUARIO\"\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        textViewSaudacao = findViewById(R.id.textViewSaudacao)\n        editTextNome = findViewById(R.id.editTextNome)\n        buttonSalvar = findViewById(R.id.buttonSalvar)\n\n        sharedPreferences = getSharedPreferences(ARQUIVO_PREFS, MODE_PRIVATE)\n\n        carregarSaudacao()\n\n        buttonSalvar.setOnClickListener {\n            salvarNome()\n        }\n    }\n\n    private fun carregarSaudacao() {\n        val nomeSalvo = sharedPreferences.getString(CHAVE_NOME, null)\n        if (nomeSalvo != null && nomeSalvo.isNotBlank()) {\n            textViewSaudacao.text = \"Olá, $nomeSalvo!\"\n        } else {\n            textViewSaudacao.text = \"Olá, Visitante!\"\n        }\n    }\n\n    private fun salvarNome() {\n        val nomeDigitado = editTextNome.text.toString()\n        if (nomeDigitado.isNotBlank()) {\n            val editor = sharedPreferences.edit()\n            editor.putString(CHAVE_NOME, nomeDigitado)\n            editor.apply()\n\n            textViewSaudacao.text = \"Olá, $nomeDigitado!\"\n            editTextNome.text.clear()\n        }\n    }\n}"
        }
      ]
    },
    {
      "type": "callout",
      "variant": "task",
      "title": "Tarefa para a próxima aula (TED)",
      "content": [
        {
          "type": "paragraph",
          "text": "Valide o app construído e registre evidências."
        },
        {
          "type": "list",
          "ordered": true,
          "items": [
            "Replique a atividade prática garantindo que o nome salvo retorne após fechar e abrir o app.",
            "Registre capturas de tela mostrando a saudação personalizada.",
            "Envie o print e uma breve descrição da experiência no Moodle."
          ]
        }
      ]
    },
    {
      "type": "bibliography",
      "title": "Bibliografia recomendada",
      "items": [
        "OLIVEIRA, Diego Bittencourt de et al. Desenvolvimento para Dispositivos Móveis. Porto Alegre: SAGAH, 2019. v. 1.",
        "SIMAS, V. L. et al. Desenvolvimento para Dispositivos Móveis – Volume 2. Grupo A, 2019.",
        "Documentação oficial sobre SharedPreferences (https://developer.android.com/training/data-storage/shared-preferences)."
      ]
    }
  ],
  "formatVersion": "md3.lesson.v1",
  "slug": "persistencia-com-shared-preferences",
  "summary": "Explora como persistir preferências e dados leves no Android usando SharedPreferences, comparando vantagens, armadilhas e boas práticas para manter configurações consistentes.",
  "objectives": [
    "Mapear casos de uso adequados para SharedPreferences em apps Kotlin.",
    "Aplicar leitura, escrita e atualização de pares chave-valor com segurança.",
    "Planejar migrações para soluções mais robustas quando necessário."
  ],
  "competencies": [
    "Persistência de dados em aplicativos móveis",
    "Modelagem de estado em aplicativos Android",
    "Uso de APIs nativas com boas práticas de segurança"
  ],
  "skills": [
    "Configurar SharedPreferences em Activities e ViewModels.",
    "Sincronizar preferências com elementos de interface reativos.",
    "Identificar limitações de SharedPreferences e propor alternativas."
  ],
  "outcomes": [
    "Salva e recupera dados usando SharedPreferences em um app Kotlin.",
    "Implementa listeners para reagir a alterações de preferências.",
    "Documenta critérios para migrar de SharedPreferences para DataStore ou Room."
  ],
  "prerequisites": [
    "Ciclo de vida de Activities e Fragments.",
    "Conceitos de estado e ViewModel na arquitetura Android."
  ],
  "tags": ["android", "persistencia", "shared-preferences"],
  "duration": 110,
  "modality": "in-person",
  "resources": [
    {
      "label": "SharedPreferences overview",
      "url": "https://developer.android.com/training/data-storage/shared-preferences",
      "type": "article"
    },
    {
      "label": "DataStore vs SharedPreferences",
      "url": "https://developer.android.com/topic/libraries/architecture/datastore",
      "type": "reference"
    }
  ],
  "bibliography": [
    "ANDROID DEVELOPERS. Data and file storage overview. 2024.",
    "PHILLIPS, M. Kotlin Apprentice. raywenderlich, 2023."
  ],
  "assessment": {
    "type": "formative",
    "description": "Checklist da atividade guiada para salvar preferências de usuário em um app de notas."
  },
  "metadata": {
    "status": "in-review",
    "updatedAt": "2024-06-10T00:00:00.000Z",
    "owners": ["Prof. João Lima", "Profa. Ana Bezerra"],
    "sources": ["Plano de ensino DDM 2024.2", "Notas de laboratório Persistência"]
  }
}
