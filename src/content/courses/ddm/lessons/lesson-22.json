{
  "formatVersion": "md3.lesson.v1",
  "id": "lesson-22",
  "title": "Aula 22: State Hoisting e ViewModel no Compose",
  "slug": "state-hoisting-viewmodel-compose",
  "summary": "Refatora a tela Compose para desacoplar estado, conectar com ViewModel e garantir recomposições eficientes.",
  "objective": "Aplicar state hoisting, ViewModel e Flow no Jetpack Compose garantindo previsibilidade e performance.",
  "objectives": [
    "Identificar onde o estado deve residir (UI vs ViewModel).",
    "Usar `StateFlow`/`Flow` para entregar dados reativos ao Compose.",
    "Implementar eventos unidirecionais com sealed classes.",
    "Medir recomposições usando ferramentas de inspeção."
  ],
  "competencies": ["Gerenciamento de estado", "Arquitetura MVVM", "Perfis de recomposição"],
  "skills": [
    "Refatorar Composables para receber estado por parâmetro.",
    "Integrar `collectAsStateWithLifecycle`.",
    "Utilizar `SnapshotStateList` e diffs em listas.",
    "Rodar `Layout Inspector` e `Recomposition Counts`."
  ],
  "outcomes": [
    "Tela Compose desacoplada com preview e testes.",
    "ViewModel emitindo estados imutáveis.",
    "Relatório de recomposições entregue no Moodle."
  ],
  "prerequisites": ["Aula 21"],
  "tags": ["android", "compose", "state", "viewmodel"],
  "duration": 120,
  "modality": "in-person",
  "resources": [
    {
      "label": "State and Jetpack Compose",
      "url": "https://developer.android.com/jetpack/compose/state",
      "type": "guide"
    },
    {
      "label": "Compose and ViewModel",
      "url": "https://developer.android.com/jetpack/compose/state#viewmodel-state",
      "type": "article"
    },
    {
      "label": "Performance best practices",
      "url": "https://developer.android.com/jetpack/compose/performance",
      "type": "guide"
    }
  ],
  "bibliography": [
    "Google. Compose performance guide. 2024.",
    "Android Dev BR. UDF com Compose. 2024.",
    "Razeware. State Management in Compose. 2023."
  ],
  "assessment": {
    "type": "formative",
    "description": "Rubrica avaliando clareza do fluxo unidirecional, estabilidade de estado e recomposições."
  },
  "content": [
    {
      "type": "videos",
      "title": "Vídeos em português",
      "videos": [
        {
          "url": "https://www.youtube.com/watch?v=8uIsYECNfwQ",
          "title": "Gerenciando estado no Compose (Android Dev BR)",
          "caption": "Explica state hoisting, ViewModel e Flow em português."
        },
        {
          "url": "https://www.youtube.com/watch?v=5Z0wzfm-Kx0",
          "title": "Fluxo unidirecional com Compose (Kotliners Brasil)",
          "caption": "Demonstra arquitetura UDF e testes de recomposição."
        }
      ]
    },
    {
      "type": "flightPlan",
      "title": "Plano da aula",
      "items": [
        "(15 min) Warm-up: revisar tela criada na aula 21 e mapear estados locais.",
        "(25 min) Demo: refatoração para state hoisting + ViewModel + Flow.",
        "(45 min) Laboratório guiado: implementar eventos e derivar estados imutáveis.",
        "(20 min) Medição: usar Layout Inspector/Recomposition Counts e registrar métricas.",
        "(15 min) Retro: discutir gargalos e combinar ajustes da sprint."
      ]
    },
    {
      "type": "contentBlock",
      "title": "Estudo de caso – Lista Viva: estado confuso",
      "content": [
        {
          "type": "paragraph",
          "text": "O app de compras Lista Viva usa Compose, mas usuários relatam itens duplicados e listas que perdem sincronização após rotacionar o aparelho."
        },
        {
          "type": "paragraph",
          "text": "Estados locais foram espalhados por vários Composables. A equipe quer consolidar o fluxo com ViewModel e Flow para garantir previsibilidade."
        },
        {
          "type": "unorderedList",
          "items": [
            "Usuários ativos: 58 mil",
            "Principais sintomas: Duplicação de itens e inconsistência após restore do processo",
            "Objetivo: Zero bugs de estado crítico na próxima release"
          ]
        },
        {
          "type": "unorderedList",
          "items": [
            "Pergunta: Quais estados devem ser promovidos ao ViewModel?",
            "Pergunta: Como estruturar eventos unidirecionais para evitar efeitos colaterais?",
            "Pergunta: Que ferramentas ajudam a medir recomposição e detectar hotspots?"
          ]
        },
        {
          "type": "unorderedList",
          "items": [
            "Ação sugerida: Mapear estados locais e decidir quais sobem para o ViewModel.",
            "Ação sugerida: Implementar `UiState` imutável e eventos representados por sealed classes.",
            "Ação sugerida: Configurar Layout Inspector para monitorar recomposições durante testes."
          ]
        }
      ]
    },
    {
      "type": "callout",
      "variant": "info",
      "title": "Ferramentas de inspeção",
      "content": "Utilize o atalho `Ctrl + Shift + P` no Android Studio para abrir o painel de recomposição e capturar screenshots para o relatório."
    },
    {
      "type": "contentBlock",
      "title": "Fluxo unidirecional",
      "content": [
        {
          "type": "image",
          "src": "https://developer.android.com/static/images/jetpack/compose/architecture/udf.png",
          "alt": "Diagrama de fluxo unidirecional"
        },
        {
          "type": "orderedList",
          "items": [
            {
              "title": "Eventos",
              "text": "UI dispara eventos para ViewModel (ex.: `OnSubmit`)."
            },
            {
              "title": "Use cases",
              "text": "Executam lógica e retornam resultados imutáveis."
            },
            {
              "title": "UiState",
              "text": "ViewModel expõe `data class` com estado completo, consumido pelo Compose."
            }
          ]
        }
      ]
    },
    {
      "type": "stepper",
      "title": "Ciclo de refatoração de estado",
      "steps": [
        {
          "title": "Auditoria",
          "description": "Documente onde o estado vive hoje e identifique fontes de verdade duplicadas."
        },
        {
          "title": "Modelagem",
          "description": "Defina `UiState`, eventos e use cases responsáveis por atualizar os dados."
        },
        {
          "title": "Integração",
          "description": "Conecte ViewModel ao Compose com `collectAsStateWithLifecycle` e injete dependências."
        },
        {
          "title": "Monitoramento",
          "description": "Meça recomposições, ajuste snapshots e registre indicadores no relatório."
        }
      ]
    },
    {
      "type": "pipelineCanvas",
      "title": "Pipeline de refatoração",
      "summary": "Garantir que a tela Compose esteja pronta para testes e manutenção.",
      "stages": [
        {
          "id": "auditoria",
          "title": "1. Auditoria",
          "summary": "Mapear estados locais, side effects e dependências.",
          "status": "in-progress",
          "owners": ["Mobile"],
          "deliverables": [
            {
              "id": "mapa",
              "label": "Mapa de estados"
            },
            {
              "id": "risco",
              "label": "Riscos identificados"
            }
          ]
        },
        {
          "id": "refatoracao",
          "title": "2. Refatoração",
          "summary": "Aplicar state hoisting, ViewModel e testes.",
          "status": "not-started",
          "owners": ["Mobile"],
          "deliverables": [
            {
              "id": "viewmodel",
              "label": "ViewModel final"
            },
            {
              "id": "tests",
              "label": "Testes de recomposição"
            }
          ]
        },
        {
          "id": "qa",
          "title": "3. QA",
          "summary": "Validar métricas de recomposição e impacto no consumo.",
          "status": "not-started",
          "owners": ["QA"],
          "deliverables": [
            {
              "id": "relatorio",
              "label": "Relatório com prints"
            },
            {
              "id": "backlog",
              "label": "Backlog de melhorias"
            }
          ]
        }
      ]
    },
    {
      "type": "quiz",
      "title": "Checagem rápida",
      "question": "Após mover o estado para o ViewModel, a tela continua atualizando em excesso. Qual ação ajuda a estabilizar as recomposições?",
      "options": [
        {
          "id": "opt-1",
          "text": "Garantir que `UiState` seja um data class imutável e utilizar `distinctUntilChanged()` antes de expor o Flow.",
          "correct": true
        },
        {
          "id": "opt-2",
          "text": "Adicionar `mutableStateOf` dentro de cada Composable para quebrar a atualização.",
          "correct": false
        },
        {
          "id": "opt-3",
          "text": "Rodar o Flow em `Dispatchers.Default` para não impactar a UI.",
          "correct": false
        }
      ],
      "allowRetry": true,
      "feedback": {
        "correct": "Imutabilidade e filtros evitam recomposições desnecessárias e mantêm o fluxo previsível.",
        "incorrect": "Imutabilidade e filtros evitam recomposições desnecessárias e mantêm o fluxo previsível."
      }
    },
    {
      "type": "callout",
      "variant": "task",
      "title": "TED – Diagnóstico de estado",
      "content": "Envie relatório (Notion ou PDF) com mapa de estado, prints de recomposição e commit `STATE_A22` implementando ViewModel + Flow."
    }
  ],
  "metadata": {
    "status": "in-review",
    "updatedAt": "2025-02-10T00:00:00.000Z",
    "owners": ["Equipe de Conteúdo DDM"],
    "sources": ["Plano de ensino DDM 2025.2", "Revisão docente fev/2025"]
  }
}
