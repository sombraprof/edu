{
  "id": "lesson-11",
  "title": "Aula 11: Métodos, Eventos e Corrotinas",
  "objective": "Utilizar eventos e corrotinas para coordenar fluxos de jogo reativos.",
  "content": [
    {
      "type": "flightPlan",
      "title": "Mapa da aula",
      "items": [
        "Revisão: Ciclo de vida MonoBehaviour e métodos auxiliares.",
        "Eventos: Criar e ouvir eventos para comunicação entre objetos.",
        "Corrotinas: Controlar fluxos temporizados sem travar a thread principal.",
        "Hands-on: Construir uma sequência de spawn com feedback audiovisual.",
        "Wrap-up: Registrar aprendizados no GDD técnico."
      ]
    },
    {
      "type": "contentBlock",
      "title": "Delegates e eventos",
      "content": [
        {
          "type": "code",
          "language": "csharp",
          "code": "public class ScoreManager : MonoBehaviour\n{\n    public static event Action OnScoreChanged;\n\n    private int currentScore;\n\n    public void AddPoints(int value)\n    {\n        currentScore += value;\n        OnScoreChanged?.Invoke(currentScore);\n    }\n}\n\npublic class HudScore : MonoBehaviour\n{\n    private void OnEnable() => ScoreManager.OnScoreChanged += UpdateLabel;\n    private void OnDisable() => ScoreManager.OnScoreChanged -= UpdateLabel;\n\n    private void UpdateLabel(int score)\n    {\n        // Atualiza UI\n    }\n}\n"
        },
        {
          "type": "callout",
          "variant": "warning",
          "title": "Cuidado com vazamentos",
          "content": [
            {
              "type": "paragraph",
              "text": "Sempre desinscreva listeners em OnDisable ou OnDestroy para evitar chamadas em objetos destruídos."
            }
          ]
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "Corrotinas na prática",
      "content": [
        {
          "type": "code",
          "language": "csharp",
          "code": "public class EnemySpawner : MonoBehaviour\n{\n    [SerializeField] private GameObject enemyPrefab;\n    [SerializeField] private float delay = 1.5f;\n\n    private void OnEnable()\n    {\n        StartCoroutine(SpawnRoutine());\n    }\n\n    private IEnumerator SpawnRoutine()\n    {\n        while (true)\n        {\n            Instantiate(enemyPrefab, transform.position, Quaternion.identity);\n            yield return new WaitForSeconds(delay);\n        }\n    }\n}\n"
        },
        {
          "type": "callout",
          "variant": "info",
          "title": "Boas práticas",
          "content": [
            {
              "type": "paragraph",
              "text": "Prefira yield return null para esperar um frame e WaitForSeconds para intervalos. Para parar, use StopCoroutine ou controle booleano."
            }
          ]
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "Desafio guiado",
      "content": [
        {
          "type": "orderedList",
          "items": [
            {
              "title": "Gatilho de evento",
              "text": "Quando o jogador coleta um item, dispare um evento que atualiza HUD e reproduz som."
            },
            {
              "title": "Sequência temporizada",
              "text": "Implemente uma corrotina que pisca luzes antes da aparição do chefe."
            },
            {
              "title": "Finalização",
              "text": "Ao derrotar o chefe, pare todas as corrotinas ativas e exiba mensagem de vitória."
            }
          ]
        }
      ]
    },
    {
      "type": "checklist",
      "title": "Pronto para seguir?",
      "items": [
        "Eventos não disparam múltiplas vezes para o mesmo listener.",
        "Corrotinas são interrompidas corretamente ao sair da cena.",
        "Fluxos documentados no repositório com comentários e README atualizado."
      ]
    }
  ],
  "formatVersion": "md3.lesson.v1",
  "slug": "metodos-eventos-e-corrotinas",
  "summary": "Aprofunda scripts em C# trabalhando com métodos, eventos Unity e corrotinas para controlar fluxos assíncronos.",
  "objectives": [
    "Diferenciar métodos síncronos e corrotinas em Unity.",
    "Configurar eventos e delegados para comunicação entre componentes.",
    "Sincronizar estados do jogo com timers e gatilhos."
  ],
  "competencies": ["Arquitetura de gameplay", "Programação assíncrona", "Engenharia de software"],
  "skills": [
    "Criar corrotinas com StartCoroutine e WaitForSeconds.",
    "Disparar eventos customizados para modularizar comportamento.",
    "Registrar listeners e remover subscrições com segurança."
  ],
  "outcomes": [
    "Implementa corrotinas para sequências temporizadas.",
    "Integra eventos para desacoplar componentes.",
    "Documenta fluxos reativos no GDD técnico."
  ],
  "prerequisites": ["Fundamentos de C# na Unity.", "Conhecimento de loops e condicionais."],
  "tags": ["unity", "corrotinas", "eventos"],
  "duration": 150,
  "modality": "in-person",
  "resources": [
    {
      "label": "Unity Manual – Coroutines",
      "url": "https://docs.unity3d.com/Manual/Coroutines.html",
      "type": "documentation"
    },
    {
      "label": "Unity Events Tutorial",
      "url": "https://learn.unity.com/tutorial/events-and-delegates",
      "type": "course"
    }
  ],
  "bibliography": [
    "HARRISON, T. Learning C# by Developing Games with Unity. Packt, 2023.",
    "Unity Technologies. Events and Messaging Systems. 2024."
  ],
  "assessment": {
    "type": "practical",
    "description": "Desafio guiado de sequência temporal com feedback da turma."
  },
  "metadata": {
    "status": "published",
    "updatedAt": "2025-02-05T00:00:00.000Z",
    "owners": ["Prof. Lucas Azevedo"],
    "sources": ["Plano de ensino TDJD 2025.1"]
  }
}
