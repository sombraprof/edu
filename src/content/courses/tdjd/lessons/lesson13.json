{
  "id": "lesson13",
  "title": "Aula 13: Projeto Final",
  "objective": "",
  "content": [
    {
      "type": "legacySection",
      "id": "plano-aula",
      "title": "Plano da Aula",
      "html": "<div data-legacy-grid=\"\"> <div data-legacy-card=\"\"> <h3><span class=\"legacy-section__icon\" aria-hidden=\"true\" data-legacy-icon=\"book-open\">üìñ</span>CONTE√öDO</h3> <p>Introdu√ß√£o √† Arquitetura Baseada em Componentes (CBA). Organiza√ß√£o de scripts e responsabilidades. Rela√ß√£o entre GameObjects, componentes e scripts.</p> </div> <div data-legacy-card=\"\"> <h3><span class=\"legacy-section__icon\" aria-hidden=\"true\" data-legacy-icon=\"bullseye\">üéØ</span>OBJETIVO</h3> <p>Compreender o paradigma da Unity e aplicar o modelo de CBA para estruturar comportamentos de forma modular e reutiliz√°vel.</p> </div> <div data-legacy-card=\"\"> <h3>METODOLOGIA</h3> <p>Aula pr√°tica com an√°lise e refatora√ß√£o de scripts, contrastando um exemplo monol√≠tico com uma solu√ß√£o modular (estudo de arquitetura aplicada).</p> </div> </div>"
    },
    {
      "type": "legacySection",
      "id": "paradigma",
      "title": "O Fim do \"Faz-Tudo\": Por Que Arquitetura Importa?",
      "html": "<div data-legacy-card=\"\"> <p>At√© agora, focamos em fazer nossos scripts funcionarem. Hoje, vamos focar em faz√™-los funcionarem <strong>bem</strong>. Em desenvolvimento de software, e especialmente em jogos, a complexidade cresce exponencialmente. Uma boa arquitetura n√£o √© um luxo, √© uma necessidade para que o projeto n√£o se torne imposs√≠vel de manter.</p> <p>A Unity √© constru√≠da sobre um poderoso paradigma de design de software: a <strong>Arquitetura Baseada em Componentes (CBA)</strong>. A ideia central √© simples e elegante:</p> <blockquote> \"Prefira <strong>Composi√ß√£o</strong> em vez de <strong>Heran√ßa</strong>.\" </blockquote> <p>Isso significa que, em vez de criar uma classe gigante `Player` que herda de `Character`, que herda de `MovableObject` em uma complexa √°rvore de heran√ßa, n√≥s criamos um `GameObject` vazio e o \"montamos\" com pe√ßas menores e independentes: um componente para movimento, um para vida, um para ataque, e assim por diante.</p> <div> <h4>Analogia: Montando um Carro</h4> <p>Pense em um carro. Ele n√£o √© uma √∫nica pe√ßa monol√≠tica. Ele √© um chassi (o `GameObject`) ao qual voc√™ adiciona componentes: um `Motor`, `Rodas`, um `SistemaDeFreio`, etc. Cada componente tem uma √∫nica responsabilidade e pode ser trocado ou melhorado sem afetar os outros. A Unity funciona da mesma forma.</p> </div> </div>"
    },
    {
      "type": "legacySection",
      "id": "monolito-vs-modular",
      "title": "O Mon√≥lito vs. O Modular",
      "html": "<p>Vamos analisar um problema comum: um script que tenta fazer tudo. Chamamos isso de <strong>Script Monol√≠tico</strong> ou \"God Class\".</p> <div data-legacy-card=\"\"> <!-- Monolith Column --> <article> <h3>O Anti-Padr√£o: Script Monol√≠tico</h3> <p>Um √∫nico script `Player.cs` controla movimento, vida, ataque, som e anima√ß√£o.</p> <div> <button onclick=\"copiarCodigo(this, 'codigo-monolito')\">Copiar</button> <pre><code id=\"codigo-monolito\">public class Player : MonoBehaviour\n{ // Movement variables public float speed; private Vector2 moveInput; // Health variables public int maxHealth; private int currentHealth; // Attack variables public int attackDamage; public float attackRate; void Update() { // Movement logic... HandleMovement(); // Attack logic... HandleAttack(); } void HandleMovement() { /* ... */ } void HandleAttack() { /* ... */ } public void TakeDamage(int damage) { currentHealth -= damage; // Play sound, update UI, check for death... }\n}</code></pre> </div> <h4>Problemas:</h4> <ul> <li><strong>Dif√≠cil de ler e manter:</strong> Centenas de linhas com responsabilidades misturadas.</li> <li><strong>N√£o reutiliz√°vel:</strong> Como usar a l√≥gica de vida em um inimigo? Copiando e colando?</li> <li><strong>Propenso a bugs:</strong> Mudar a l√≥gica de ataque pode quebrar o movimento.</li> <li><strong>Ruim para colabora√ß√£o:</strong> Dois programadores n√£o podem trabalhar no mesmo arquivo ao mesmo tempo.</li> </ul> </article> <!-- Modular Column --> <article> <h3>O Padr√£o Unity: Componentes</h3> <p>O mesmo comportamento √© dividido em scripts menores e focados.</p> <div> <div><strong>PlayerMovement.cs:</strong> Controla apenas o movimento.</div> <div><strong>Health.cs:</strong> Gerencia apenas a vida. Pode ser usado no Player, em inimigos, em caixas destrut√≠veis...</div> <div><strong>Attacker.cs:</strong> Lida apenas com a l√≥gica de ataque.</div> </div> <h4>Vantagens:</h4> <ul> <li><strong>Princ√≠pio da Responsabilidade √önica (SOLID):</strong> Cada classe faz uma √∫nica coisa.</li> <li><strong>Reutiliz√°vel:</strong> O componente `Health.cs` pode ser anexado a qualquer GameObject.</li> <li><strong>F√°cil de testar e depurar:</strong> Se a vida est√° com bug, voc√™ sabe que o problema est√° no `Health.cs`.</li> <li><strong>Flex√≠vel:</strong> Quer um inimigo que se move mas n√£o ataca? Anexe apenas `EnemyMovement.cs` e `Health.cs`.</li> </ul> </article> </div>"
    },
    {
      "type": "legacySection",
      "id": "comunicacao",
      "title": "Como Componentes Conversam Entre Si?",
      "html": "<div data-legacy-grid=\"\"> <p>Se os scripts s√£o separados, como o componente de ataque sabe que precisa reduzir a vida no componente de vida? Existem v√°rias estrat√©gias de comunica√ß√£o, cada uma com seus pr√≥s e contras.</p> <h3>1. `GetComponent<t>()`</t></h3> <p>A forma mais direta de um componente encontrar outro no mesmo GameObject.</p> <div data-legacy-card=\"\"> <button onclick=\"copiarCodigo(this, 'codigo-getcomponent')\">Copiar</button> <pre><code id=\"codigo-getcomponent\">// Em um script 'DamageZone.cs'\nprivate void OnTriggerEnter(Collider other)\n{ // Try to find a Health component on the object we collided with Health targetHealth = other.GetComponent<health>(); if (targetHealth != null) { targetHealth.TakeDamage(10); }\n}</health></code></pre> </div> <div data-legacy-card=\"\"><strong>Boa Pr√°tica:</strong> `GetComponent` pode ser lento. Se voc√™ precisa da refer√™ncia com frequ√™ncia, chame-o uma vez no m√©todo `Awake()` ou `Start()` e armazene o resultado em uma vari√°vel (cache).</div> <h3>2. Refer√™ncias Diretas com `[SerializeField]`</h3> <p>Exponha uma vari√°vel no Inspector e arraste a refer√™ncia manualmente. √â √≥timo para conectar objetos diferentes na cena.</p> <div data-legacy-card=\"\"> <button onclick=\"copiarCodigo(this, 'codigo-serializefield')\">Copiar</button> <pre><code id=\"codigo-serializefield\">// Em um script 'UIManager.cs'\npublic class UIManager : MonoBehaviour\n{ [SerializeField] private Health playerHealth; // Drag the Player's Health component here in the Inspector [SerializeField] private Text healthText; private void Update() { healthText.text = \"HP: \" + playerHealth.GetCurrentHealth(); }\n}</code></pre> </div> <div data-legacy-card=\"\"><strong>Vantagem:</strong> Cria um acoplamento fraco. O `UIManager` n√£o precisa saber como encontrar o `playerHealth`, ele apenas recebe a refer√™ncia.</div> </div>"
    },
    {
      "type": "legacySection",
      "id": "tarefa",
      "title": "üìù Tarefa (TED): Refatorando um Script Monol√≠tico",
      "html": "<div data-legacy-card=\"\"> <p>Sua tarefa √© pegar um script monol√≠tico que controla uma porta e refator√°-lo, aplicando os princ√≠pios da Arquitetura Baseada em Componentes.</p> <h4>O Script \"Antes\" (Monol√≠tico):</h4> <div> <button onclick=\"copiarCodigo(this, 'codigo-ted-antes')\">Copiar</button> <pre><code id=\"codigo-ted-antes\">public class MonolithicDoor : MonoBehaviour\n{ public bool isLocked = false; public AudioClip openSound; public AudioClip closeSound; private bool isOpen = false; private AudioSource audioSource; private Animator animator; void Awake() { audioSource = GetComponent<audiosource>(); animator = GetComponent<animator>(); } public void Interact() { if (isLocked) return; isOpen = !isOpen; animator.SetBool(\"IsOpen\", isOpen); if (isOpen) { audioSource.PlayOneShot(openSound); } else { audioSource.PlayOneShot(closeSound); } }\n}</animator></audiosource></code></pre> </div> <h4>Sua Miss√£o:</h4> <ol> <li>Crie um projeto Unity simples. Crie um GameObject \"Porta\".</li> <li>Crie os seguintes scripts, separando as responsabilidades do script acima: <ul> <li><code>DoorInteraction.cs</code>: Deve detectar a intera√ß√£o (ex: um m√©todo p√∫blico `Interact()`).</li> <li><code>DoorAnimator.cs</code>: Deve ser respons√°vel <strong>apenas</strong> por controlar o `Animator`.</li> <li><code>DoorAudio.cs</code>: Deve ser respons√°vel <strong>apenas</strong> por tocar os sons de abrir e fechar.</li> <li><code>DoorLockSystem.cs</code>: Deve gerenciar <strong>apenas</strong> o estado de \"trancada\" (`isLocked`).</li> </ul> </li> <li>Use `GetComponent` dentro dos scripts para que eles se comuniquem (ex: `DoorInteraction` chama m√©todos em `DoorAnimator` e `DoorAudio`).</li> <li><strong>Entrega:</strong> Poste no Moodle os 4 novos scripts em blocos de c√≥digo. Abaixo de cada um, escreva uma frase explicando sua √∫nica responsabilidade.</li> </ol> </div>"
    },
    {
      "type": "legacySection",
      "id": "recursos",
      "title": "üìö Recursos Adicionais",
      "html": "<div data-legacy-grid=\"\"> <div data-legacy-card=\"\"><h4>Documenta√ß√£o Oficial da Unity</h4><ul> <li><a href=\"https://docs.unity3d.com/Manual/CreatingAndUsingScripts.html\" target=\"_blank\" rel=\"noopener noreferrer\">Creating and Using Scripts</a></li> <li><a href=\"https://docs.unity3d.com/Manual/ComponentReference.html\" target=\"_blank\" rel=\"noopener noreferrer\">Component Reference</a></li> <li><a href=\"https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html\" target=\"_blank\" rel=\"noopener noreferrer\">Scripting API: GetComponent</a></li> </ul></div> <div data-legacy-card=\"\"><h4>Artigos e V√≠deos</h4><ul> <li><a href=\"https://www.gamedeveloper.com/design/unity-s-component-based-architecture\" target=\"_blank\" rel=\"noopener noreferrer\">Unity's Component-Based Architecture (Game Developer)</a></li> <li><a href=\"https://www.youtube.com/watch?v=k_i8a-9t_pA\" target=\"_blank\" rel=\"noopener noreferrer\">SOLID Principles in C# for Unity (Video)</a></li> <li><a href=\"https://www.youtube.com/watch?v=k_Q_wzz-Q5c\" target=\"_blank\" rel=\"noopener noreferrer\">Comunica√ß√£o entre Scripts na Unity (F√°brica de Jogos - PT-BR)</a></li> </ul></div> </div>"
    },
    {
      "type": "legacySection",
      "id": "bibliografia",
      "title": "üìö Bibliografia",
      "html": "<div data-legacy-card=\"\"> <p>ALVES, W. P. <strong>Unity: design e desenvolvimento de jogos.</strong> Rio de Janeiro: Alta Books, 2019.</p> <p>MASTROCOLA, Vicente Martin. <strong>Game design: modelos de neg√≥cio e processos criativos.</strong> S√£o Paulo: Cengage Learning, 2015.</p> </div>"
    }
  ]
}
