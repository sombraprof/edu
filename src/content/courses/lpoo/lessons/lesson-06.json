{
  "formatVersion": "md3.lesson.v1",
  "id": "lesson-06",
  "title": "Aula 6: Aprofundando em Herança e Polimorfismo",
  "summary": "Explora boas práticas de herança, sobrescrita de métodos, uso de `@Override` e polimorfismo em coleções e serviços.",
  "objective": "Projetar hierarquias flexíveis que suportem extensão segura e testes automatizados.",
  "objectives": [
    "Implementar sobrescrita controlada com `@Override` e chamadas a `super`.",
    "Utilizar polimorfismo para reduzir condicionais e melhorar extensibilidade.",
    "Configurar testes unitários que demonstrem comportamento polimórfico."
  ],
  "competencies": [
    "Design orientado a objetos",
    "Qualidade de código e testes",
    "Refatoração sustentável"
  ],
  "skills": [
    "Aplicar `final` para proteger classes e métodos de alterações indevidas.",
    "Criar hierarquias que suportem injeção de dependências com interfaces.",
    "Utilizar coleções de supertipo e iterar chamando métodos polimórficos."
  ],
  "outcomes": [
    "Teste automatizado validando polimorfismo.",
    "Refatoração de condicionais para uso de herança/strategies.",
    "Checklist de revisão antes de introduzir nova subclasse."
  ],
  "prerequisites": [
    "Domínio dos conceitos básicos de herança (aula 05).",
    "Conhecimento de estruturas de decisão e loops."
  ],
  "tags": ["poo", "polimorfismo", "java"],
  "duration": 120,
  "modality": "in-person",
  "resources": [
    {
      "label": "Artigo Baeldung sobre Polimorfismo",
      "type": "article",
      "url": "https://www.baeldung.com/java-polymorphism"
    },
    {
      "label": "JUnit 5 User Guide",
      "type": "documentation",
      "url": "https://junit.org/junit5/docs/current/user-guide/"
    },
    {
      "label": "Exercício: Refatoração orientada a objetos",
      "type": "exercise",
      "url": "https://edu.local/courses/lpoo/exercises/refactoring"
    },
    {
      "label": "Oracle Developer Live – Herança e Polimorfismo em Profundidade",
      "type": "video",
      "url": "https://www.youtube.com/watch?v=fxQ6jF7zpHg",
      "duration": "PT36M27S",
      "studyObjective": "Ver um exemplo completo de hierarquia extensível, com polimorfismo dinâmico aplicado a um caso real."
    },
    {
      "label": "DevDojo Maratona Java – Polimorfismo na prática",
      "type": "video",
      "url": "https://www.youtube.com/watch?v=E9hjYn-D5A0",
      "duration": "PT25M09S",
      "studyObjective": "Reforçar o uso de interfaces e classes abstratas em cenários reais de cálculo de imposto e relatórios."
    }
  ],
  "bibliography": [
    "MARTIN, R. Agile Software Development: Principles, Patterns, and Practices. 2. ed. Prentice Hall, 2022.",
    "ROBERTS, D. et al. Refactoring to Patterns. Pearson, 2021."
  ],
  "assessment": {
    "type": "practice",
    "description": "Laboratório avaliativo substituindo condicionais por polimorfismo e cobrindo o fluxo com testes unitários.",
    "rubric": "Código sem `instanceof` desnecessário, testes executando com 100% de sucesso e relatório explicando decisões."
  },
  "content": [
    {
      "type": "lessonPlan",
      "title": "Plano da aula",
      "unit": {
        "title": "Unidade II — Polimorfismo e extensibilidade",
        "content": "Aprimorar hierarquias implementando comportamentos especializados e validando por testes."
      },
      "cards": [
        {
          "icon": "code",
          "title": "Sobrescrita consciente",
          "content": "Usar `@Override` como contrato e garantir a compatibilidade Liskov."
        },
        {
          "icon": "database",
          "title": "Polimorfismo",
          "content": "Trabalhar com coleções e serviços que aceitam o tipo mais genérico possível."
        },
        {
          "icon": "check-circle",
          "title": "Testes",
          "content": "Automatizar cenários com JUnit para validar substituições."
        }
      ]
    },
    {
      "type": "flightPlan",
      "title": "Plano de voo (2h00)",
      "items": [
        "(15 min) Revisão das hierarquias criadas na aula anterior.",
        "(25 min) Mini aula: princípios LSP e uso de `final`.",
        "(25 min) Laboratório: refatorando condicionais para polimorfismo.",
        "(20 min) Pair programming: implementando testes de regressão com JUnit.",
        "(20 min) Debate: composição vs herança em cenários reais.",
        "(15 min) Síntese e encaminhamento da tarefa assíncrona."
      ]
    },
    {
      "type": "callout",
      "variant": "warning",
      "title": "Sinal amarelo",
      "content": [
        {
          "type": "paragraph",
          "text": "Se sua hierarquia depende de muitos `instanceof`, talvez esteja faltando uma interface ou método abstrato."
        }
      ]
    },
    {
      "type": "cardGrid",
      "title": "Formas de polimorfismo em Java",
      "columns": 3,
      "cards": [
        {
          "title": "Sobrescrita",
          "subtitle": "Runtime",
          "tone": "info",
          "content": "Subclasses redefinem métodos da superclasse mantendo assinatura compatível."
        },
        {
          "title": "Sobrecarga",
          "subtitle": "Compile-time",
          "tone": "neutral",
          "content": "Múltiplas assinaturas com o mesmo nome oferecem alternativas de uso."
        },
        {
          "title": "Paramétrico",
          "subtitle": "Generics",
          "tone": "success",
          "content": "Coleções aceitam diferentes tipos mantendo segurança por tipo."
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "Fluxo mental para escolher o tipo de polimorfismo",
      "content": [
        {
          "type": "paragraph",
          "text": "Comece avaliando se o comportamento deve variar em tempo de execução. Se sim, use sobrescrita com interfaces ou classes abstratas; se a diferença é apenas na assinatura, sobrecarga é suficiente."
        },
        {
          "type": "paragraph",
          "text": "Para coleções e APIs genéricas, considere o polimorfismo paramétrico (`List<? extends Pagamento>`), preservando segurança de tipos e flexibilidade."
        },
        {
          "type": "code",
          "language": "text",
          "code": "Decisão rápida\n1. A regra muda em runtime? → Sobrescrita + interfaces/abstratas\n2. O método precisa de variações na assinatura? → Sobrecarga\n3. A coleção precisa aceitar múltiplos tipos? → Generics com limites"
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "Demonstração em código: processando pagamentos",
      "content": [
        {
          "type": "paragraph",
          "text": "O exemplo abaixo reduz condicionais usando uma interface `Pagamento`. Cada implementação encapsula sua própria regra de taxa e o serviço depende apenas do contrato."
        },
        {
          "type": "code",
          "language": "java",
          "code": "public interface Pagamento {\n    BigDecimal totalComTaxa();\n}\n\npublic class PagamentoCartao implements Pagamento {\n    private final BigDecimal valor;\n\n    public PagamentoCartao(BigDecimal valor) {\n        this.valor = valor;\n    }\n\n    @Override\n    public BigDecimal totalComTaxa() {\n        return valor.multiply(BigDecimal.valueOf(1.035));\n    }\n}\n\npublic class PagamentoPix implements Pagamento {\n    private final BigDecimal valor;\n\n    public PagamentoPix(BigDecimal valor) {\n        this.valor = valor;\n    }\n\n    @Override\n    public BigDecimal totalComTaxa() {\n        return valor;\n    }\n}\n\npublic class ServicoPagamento {\n    public BigDecimal consolidar(List<Pagamento> pagamentos) {\n        return pagamentos.stream()\n            .map(Pagamento::totalComTaxa)\n            .reduce(BigDecimal.ZERO, BigDecimal::add);\n    }\n}"
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "Coleções polimórficas em ação",
      "content": [
        {
          "type": "paragraph",
          "text": "Repare que `ServicoPagamento` recebe `List<Pagamento>` e pode iterar sobre qualquer implementação que siga o contrato. Não é necessário `instanceof`, apenas confiar na mensagem enviada."
        },
        {
          "component": "Callout",
          "props": {
            "variant": "info",
            "title": "Boas práticas",
            "content": "Prefira declarar coleções com o supertipo (`List<Pagamento>`) e instanciar com classes concretas (`new ArrayList<>()`)."
          }
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "Testes cobrindo comportamento polimórfico",
      "content": [
        {
          "type": "paragraph",
          "text": "JUnit ajuda a provar que diferentes implementações respondem da mesma forma às expectativas do serviço."
        },
        {
          "type": "code",
          "language": "java",
          "code": "@Test\nvoid deveSomarPagamentosComTaxasEspecificas() {\n    ServicoPagamento servico = new ServicoPagamento();\n    List<Pagamento> pagamentos = List.of(\n        new PagamentoCartao(new BigDecimal(\"100\")),\n        new PagamentoPix(new BigDecimal(\"200\"))\n    );\n\n    BigDecimal total = servico.consolidar(pagamentos);\n\n    assertEquals(new BigDecimal(\"303.50\"), total);\n}"
        }
      ]
    },
    {
      "type": "callout",
      "variant": "good-practice",
      "title": "Conecte com o vídeo da aula",
      "content": [
        {
          "type": "paragraph",
          "text": "Assista ao trecho 12min45s–18min02s do vídeo da Maratona Java para ver o mesmo padrão aplicado na geração de relatórios, reforçando o ciclo: interface → implementação → coleção → teste."
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "Aplicando o princípio de substituição de Liskov",
      "content": [
        {
          "type": "paragraph",
          "text": "Ao substituir uma superclasse por uma subclasse, o comportamento esperado deve permanecer consistente. Violação desse princípio gera bugs sutis."
        },
        {
          "component": "Callout",
          "props": {
            "variant": "good-practice",
            "title": "Checklist",
            "content": "Subclasses nunca devem restringir contratos (pré-condições) ou deixar de cumprir garantias (pós-condições)."
          }
        }
      ]
    },
    {
      "type": "checklist",
      "title": "Antes de criar uma nova subclasse",
      "items": [
        "Existe relação clara do tipo `é-um`?",
        "Superclasse define comportamento padrão reutilizável?",
        "Sobrescrita altera apenas detalhes específicos?",
        "Há testes cobrindo os novos cenários?"
      ]
    }
  ],
  "metadata": {
    "status": "in-review",
    "updatedAt": "2025-02-01T00:00:00.000Z",
    "owners": ["Prof. Tiago Sombra"],
    "sources": ["Plano de ensino LPOO 2025.2", "Oficina de polimorfismo 2023"]
  }
}
