{
  "id": "lesson-06",
  "title": "Aula 6: Aprofundando em Heran√ßa e Polimorfismo",
  "objective": "Capacitar o aluno a sobrescrever m√©todos, aplicar o polimorfismo para criar um c√≥digo mais flex√≠vel e entender o papel da classe Object.",
  "content": [
    {
      "type": "contentBlock",
      "title": "Ementa e Contextualiza√ß√£o",
      "content": [
        {
          "type": "paragraph",
          "text": "Na aula anterior, introduzimos a Heran√ßa como um dos pilares da POO. Agora, vamos aprofundar nosso entendimento, explorando como as subclasses podem n√£o apenas herdar, mas tamb√©m <strong>modificar</strong> comportamentos atrav√©s da <strong>sobrescrita de m√©todos</strong>. Isso nos levar√° diretamente ao conceito de <strong>Polimorfismo</strong>, talvez a caracter√≠stica mais poderosa da POO. Polimorfismo nos permite escrever um c√≥digo mais flex√≠vel, gen√©rico e extens√≠vel, tratando objetos de diferentes classes de maneira uniforme. Dominar esses conceitos √© o que separa um programador iniciante de um arquiteto de software capaz de criar sistemas robustos e de f√°cil manuten√ß√£o."
        }
      ]
    },
    {
      "type": "lessonPlan",
      "title": "Plano da Aula",
      "cards": [
        {
          "icon": "book-open",
          "title": "CONTE√öDO",
          "content": "Modificador `protected`, Sobrescrita de M√©todos (`@Override`), Polimorfismo, a classe `Object` e o m√©todo `toString()`."
        },
        {
          "icon": "bullseye",
          "title": "OBJETIVO",
          "content": "Capacitar o aluno a sobrescrever m√©todos, aplicar o polimorfismo para criar um c√≥digo mais flex√≠vel e entender o papel da classe `Object`."
        },
        {
          "icon": "gears",
          "title": "METODOLOGIA",
          "content": "Aula expositiva, exemplos comparativos de c√≥digo, e uma atividade pr√°tica focada na aplica√ß√£o do polimorfismo."
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "üìö Teoria ‚Äî An√°lise da AV1: Consolidando Nossos Conhecimentos",
      "content": [
        {
          "type": "paragraph",
          "text": "Vamos revisar um problema t√≠pico da AV1, que aborda os conceitos essenciais que vimos at√© agora: classes, objetos, atributos, m√©todos e encapsulamento."
        },
        {
          "type": "callout",
          "variant": "academic",
          "title": "Problema Exemplo: Modelar um Curso",
          "content": [
            "Crie uma classe `Curso` para representar um curso acad√™mico. A classe deve ter os atributos privados `nome` (String) e `cargaHoraria` (int). Implemente um construtor que inicialize esses atributos e m√©todos getters e setters. O setter de `cargaHoraria` deve garantir que o valor n√£o seja negativo. Crie uma classe de teste para instanciar e exibir os dados de um curso."
          ]
        },
        {
          "type": "contentBlock",
          "title": "Resolu√ß√£o Passo a Passo",
          "content": [
            {
              "type": "paragraph",
              "text": "A solu√ß√£o correta envolve criar a classe com atributos privados e fornecer acesso controlado atrav√©s de m√©todos p√∫blicos."
            },
            {
              "type": "code",
              "language": "java",
              "code": "// File: Curso.java\npublic class Curso {\n    private String nome;\n    private int cargaHoraria;\n\n    public Curso(String nome, int cargaHoraria) {\n        this.nome = nome;\n        this.setCargaHoraria(cargaHoraria); // Use the setter to ensure validation\n    }\n\n    public String getNome() {\n        return this.nome;\n    }\n\n    public int getCargaHoraria() {\n        return this.cargaHoraria;\n    }\n\n    public void setNome(String nome) {\n        this.nome = nome;\n    }\n\n    public void setCargaHoraria(int cargaHoraria) {\n        if (cargaHoraria >= 0) {\n            this.cargaHoraria = cargaHoraria;\n        } else {\n            System.out.println(\"[ERRO] Carga hor√°ria n√£o pode ser negativa.\");\n        }\n    }\n}"
            }
          ]
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "üöÄ Elevando o N√≠vel da Heran√ßa",
      "content": [
        {
          "type": "contentBlock",
          "title": "1. Visibilidade Protegida (protected)",
          "content": [
            {
              "type": "paragraph",
              "text": "At√© agora, usamos `private` para encapsulamento m√°ximo. Mas e se quisermos que uma subclasse acesse diretamente um atributo da superclasse, sem que ele seja p√∫blico para o resto do mundo? Para isso, usamos o modificador `protected`."
            },
            {
              "type": "list",
              "items": [
                "`private`: Acess√≠vel apenas dentro da pr√≥pria classe.",
                "`protected`: Acess√≠vel dentro da pr√≥pria classe, por classes no mesmo pacote e por subclasses (mesmo em pacotes diferentes).",
                "`public`: Acess√≠vel de qualquer lugar."
              ]
            },
            {
              "type": "callout",
              "variant": "info",
              "title": "Nuance importante de protected",
              "content": [
                {
                  "type": "paragraph",
                  "text": "Fora do mesmo pacote, o acesso `protected` s√≥ √© permitido em <strong>subclasses</strong> e, ainda assim, via a <em>inst√¢ncia da subclasse</em> (n√£o via refer√™ncia de `Base`)."
                },
                {
                  "type": "code",
                  "language": "java",
                  "code": "// English comments for clarity\n// package base;\npublic class Base {\n    protected int x = 42;\n}\n\n// package outro;\npublic class SubB extends Base {\n    public void ok() {\n        // OK: access via subclass instance (even if package is different)\n        this.x = 10;\n    }\n\n    public void notOk() {\n        Base b = new Base();\n        // b.x; // ERROR: cannot access protected via superclass ref from another package\n    }\n}"
                }
              ]
            }
          ]
        },
        {
          "type": "contentBlock",
          "title": "2. Sobrescrita de M√©todos (@Override)",
          "content": [
            {
              "type": "paragraph",
              "text": "Sobrescrever (ou anular) um m√©todo significa que uma subclasse fornece uma implementa√ß√£o <strong>espec√≠fica</strong> para um m√©todo que j√° √© fornecido por sua superclasse. A assinatura do m√©todo (nome e par√¢metros) deve ser id√™ntica."
            },
            {
              "type": "callout",
              "variant": "good-practice",
              "title": "A anota√ß√£o @Override",
              "content": "Embora opcional, √© uma boa pr√°tica usar a anota√ß√£o `@Override` acima de um m√©todo sobrescrito. Se houver erro na assinatura, o compilador alerta ‚Äî evitando bugs sutis."
            },
            {
              "type": "cardGrid",
              "cards": [
                {
                  "title": "Overloading (compile-time)",
                  "content": "<ul><li>Mesmo nome; <strong>assinaturas diferentes</strong>.</li><li>Resolu√ß√£o em <strong>tempo de compila√ß√£o</strong>.</li><li>N√£o envolve heran√ßa, em geral.</li></ul>"
                },
                {
                  "title": "Overriding (runtime)",
                  "content": "<ul><li><strong>Mesma assinatura</strong> em subclasse.</li><li><strong>Binding din√¢mico</strong> em execu√ß√£o.</li><li>Permite polimorfismo real.</li></ul>"
                }
              ]
            }
          ]
        },
        {
          "type": "contentBlock",
          "title": "3. Polimorfismo: M√∫ltiplas Formas",
          "content": [
            {
              "type": "paragraph",
              "text": "Polimorfismo significa \"muitas formas\". Em POO, √© a capacidade de um objeto ser referenciado de m√∫ltiplas maneiras. A forma mais comum √© usar uma vari√°vel de refer√™ncia do tipo da <strong>superclasse</strong> para apontar para um objeto da <strong>subclasse</strong>."
            },
            {
              "type": "code",
              "language": "java",
              "code": "// English comment: Upcasting allows superclass reference to point to subclass object\nFuncionario f = new Gerente(\"Ana\", 8000.0, 1500.0);"
            },
            {
              "type": "paragraph",
              "text": "A \"m√°gica\" acontece quando chamamos um m√©todo sobrescrito a partir dessa refer√™ncia. O Java, em tempo de execu√ß√£o, sabe qual √© o tipo <strong>real</strong> do objeto (`Gerente`) e chama a vers√£o correta."
            },
            {
              "type": "callout",
              "variant": "info",
              "title": "Downcasting seguro com instanceof (pattern matching)",
              "content": [
                {
                  "type": "code",
                  "language": "java",
                  "code": "// English comments: Pattern matching for instanceof (Java 16+)\nFuncionario ref = new Gerente(\"Maria\", 5000.0);\nif (ref instanceof Gerente gerente) { // auto-cast bound to variable\n    System.out.println(\"B√¥nus especial: \" + gerente.getBonificacao());\n}"
                }
              ]
            }
          ]
        },
        {
          "type": "contentBlock",
          "title": "4. A Classe Object: A M√£e de Todas",
          "content": [
            {
              "type": "paragraph",
              "text": "Em Java, toda classe herda implicitamente de `Object`. Isso garante m√©todos como `equals()`, `hashCode()` e `toString()`."
            },
            {
              "type": "paragraph",
              "text": "√â uma √≥tima pr√°tica sobrescrever `toString()` para representa√ß√µes textuais √∫teis."
            },
            {
              "type": "callout",
              "variant": "warning",
              "title": "Contrato equals() / hashCode()",
              "content": "Ao sobrescrever `equals()`, <strong>tamb√©m</strong> sobrescreva `hashCode()` de forma consistente (coer√™ncia em cole√ß√µes como `HashSet`/`HashMap`)."
            },
            {
              "type": "callout",
              "variant": "good-practice",
              "title": "Prefira composi√ß√£o a heran√ßa",
              "content": "Use heran√ßa quando respeitar o princ√≠pio de substitui√ß√£o de Liskov (LSP) e houver uma rela√ß√£o \"√©-um\". Em muitos casos, composi√ß√£o oferece <em>acoplamento menor</em> e <em>maior reuso</em>."
            }
          ]
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "üíª Praticando Polimorfismo",
      "content": [
        {
          "type": "paragraph",
          "text": "Vamos evoluir nosso exemplo `Funcionario`/`Gerente`. Adicionaremos um `Programador` e usaremos polimorfismo para calcular uma folha de pagamento."
        },
        {
          "type": "code",
          "language": "java",
          "code": "// Superclass Funcionario (educational example)\npublic class Funcionario {\n    protected String nome;   // For teaching purposes; in production prefer private + getters\n    protected double salario;\n\n    public Funcionario(String nome, double salario) {\n        this.nome = nome;\n        this.salario = salario;\n    }\n\n    // A general bonus calculation\n    public double getBonificacao() {\n        return this.salario * 0.05; // 5% bonus for a regular employee\n    }\n    \n    @Override\n    public String toString() {\n        return \"Funcionario [Nome=\" + this.nome + \", Sal√°rio=\" + this.salario + \"]\";\n    }\n}\n\n// Subclass Gerente\npublic class Gerente extends Funcionario {\n    public Gerente(String nome, double salario) {\n        super(nome, salario);\n    }\n\n    @Override // Overriding the method for a specific implementation\n    public double getBonificacao() {\n        return super.getBonificacao() + 1000.0; // 5% + a fixed bonus of 1000\n    }\n}\n\n// Subclass Programador\npublic class Programador extends Funcionario {\n     public Programador(String nome, double salario) {\n        super(nome, salario);\n    }\n    \n    @Override // Specific bonus for programmers\n    public double getBonificacao() {\n        return this.salario * 0.15; // 15% bonus for programmers\n    }\n}\n\n// Test Class\nimport java.util.List;\n\npublic class ControleBonificacao {\n    public static void main(String[] args) {\n        // Polymorphism in action: Superclass reference for subclass objects\n        Funcionario f1 = new Funcionario(\"Jo√£o\", 2000.0);\n        Funcionario g1 = new Gerente(\"Maria\", 5000.0);\n        Funcionario p1 = new Programador(\"Pedro\", 3500.0);\n\n        System.out.println(\"B√¥nus do Funcion√°rio: \" + f1.getBonificacao()); // Calls Funcionario's method\n        System.out.println(\"B√¥nus do Gerente: \" + g1.getBonificacao());     // Calls Gerente's method\n        System.out.println(\"B√¥nus do Programador: \" + p1.getBonificacao()); // Calls Programador's method\n        \n        System.out.println(f1); // Prints the result of the overridden toString() method\n        System.out.println(g1);\n\n        // Optional: polymorphic collections\n        List<Funcionario> funcionarios = List.of(f1, g1, p1);\n        double total = 0;\n        for (Funcionario f : funcionarios) {\n            total += f.getBonificacao(); // runtime dispatch\n        }\n        System.out.println(\"Total de bonifica√ß√µes: \" + total);\n    }\n}"
        },
        {
          "type": "paragraph",
          "text": "Nota: para valores monet√°rios em produ√ß√£o, prefira `BigDecimal`."
        }
      ]
    },
    {
      "type": "videosBlock",
      "title": "üé• V√≠deos e Links de Apoio",
      "videos": [
        {
          "title": "Polimorfismo em Java (DevDojo)",
          "youtubeId": "Ps2ptq1twyA"
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "Leituras Recomendadas",
      "content": [
        {
          "type": "button",
          "text": "Polymorphism (dev.java/Oracle)",
          "href": "https://dev.java/learn/inheritance/polymorphism/"
        },
        {
          "type": "button",
          "text": "Overriding and Hiding Methods (dev.java)",
          "href": "https://dev.java/learn/inheritance/overriding/"
        },
        {
          "type": "button",
          "text": "Object as a Superclass (dev.java)",
          "href": "https://dev.java/learn/inheritance/objects/"
        },
        {
          "type": "button",
          "text": "Polymorphism (The Java‚Ñ¢ Tutorials ‚Äî JDK 8)",
          "href": "https://docs.oracle.com/javase/tutorial/java/IandI/polymorphism.html"
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "Atividade Pr√°tica (TED): Figuras Geom√©tricas",
      "content": [
        {
          "type": "paragraph",
          "text": "Vamos aplicar a heran√ßa e o polimorfismo para calcular a √°rea de diferentes formas geom√©tricas."
        },
        {
          "type": "list",
          "items": [
            "**Crie a superclasse abstrata `FormaGeometrica.java`**. Ela deve declarar o m√©todo `public abstract double calcularArea()`.",
            "**Crie a subclasse `Retangulo.java`** que herda de `FormaGeometrica`. Adicione os atributos `largura` e `altura`. Implemente `calcularArea()` retornando `largura * altura`.",
            "**Crie a subclasse `Circulo.java`** que herda de `FormaGeometrica`. Adicione o atributo `raio`. Implemente `calcularArea()` retornando `Math.PI * raio * raio`.",
            "**Crie a classe `TesteFormas.java`** com um m√©todo `main`. Crie uma cole√ß√£o (`List<FormaGeometrica>`) com inst√¢ncias de `Retangulo` e `Circulo`. Percorra e imprima a √°rea de cada forma, observando o polimorfismo em a√ß√£o (binding din√¢mico)."
          ]
        },
        {
          "type": "code",
          "language": "java",
          "code": "// English comments: Abstract base class to enforce area calculation\npublic abstract class FormaGeometrica {\n    public abstract double calcularArea();\n\n    @Override\n    public String toString() {\n        return getClass().getSimpleName();\n    }\n}\n\npublic class Retangulo extends FormaGeometrica {\n    private final double largura;\n    private final double altura;\n\n    public Retangulo(double largura, double altura) {\n        this.largura = largura;\n        this.altura = altura;\n    }\n\n    @Override\n    public double calcularArea() {\n        return largura * altura;\n    }\n}\n\npublic class Circulo extends FormaGeometrica {\n    private final double raio;\n\n    public Circulo(double raio) {\n        this.raio = raio;\n    }\n\n    @Override\n    public double calcularArea() {\n        return Math.PI * raio * raio;\n    }\n}\n\nimport java.util.List;\n\npublic class TesteFormas {\n    public static void main(String[] args) {\n        List<FormaGeometrica> formas = List.of(\n            new Retangulo(3, 4),\n            new Circulo(2.5)\n        );\n\n        for (FormaGeometrica f : formas) {\n            System.out.printf(\"%s -> √°rea = %.2f%n\", f, f.calcularArea());\n        }\n    }\n}"
        }
      ]
    },
    {
      "type": "checklist",
      "title": "Checklist de Aprendizagem da Aula",
      "items": [
        "Explicar a diferen√ßa de visibilidade entre `private` e `protected`.",
        "Sobrescrever um m√©todo de uma superclasse usando a anota√ß√£o `@Override`.",
        "Definir Polimorfismo e demonstrar seu uso com uma refer√™ncia de superclasse para um objeto de subclasse.",
        "Sobrescrever o m√©todo `toString()` da classe `Object` para fornecer uma representa√ß√£o textual √∫til de um objeto."
      ]
    },
    {
      "type": "bibliographyBlock",
      "title": "üìö Bibliografia de Apoio",
      "references": [
        "<strong>DEITEL, Harvey M.; DEITEL, Paul J.</strong> <em>Java: como programar.</em> 8. ed. S√£o Paulo: Pearson Prentice Hall, 2014.",
        "<strong>SCHILDT, Herbert.</strong> <em>Java para iniciantes: crie, compile e execute programas Java rapidamente.</em> 6. ed. Porto Alegre: Bookman, 2015.",
        "<strong>GOODRICH, Michael T.; TAMASSIA, Roberto.</strong> <em>Estruturas de dados e algoritmos em Java.</em> 5. ed. Porto Alegre: Bookman, 2013."
      ]
    }
  ]
}
