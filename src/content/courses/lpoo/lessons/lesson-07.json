{
  "formatVersion": "md3.lesson.v1",
  "id": "lesson-07",
  "title": "Aula 7: Classes Abstratas e Interfaces",
  "summary": "Compara abordagens para definir contratos em Java, usando classes abstratas e interfaces para viabilizar polimorfismo e desacoplamento.",
  "objective": "Selecionar corretamente entre classes abstratas e interfaces ao modelar comportamentos compartilhados.",
  "objectives": [
    "Explicar diferenças e complementaridades entre classes abstratas e interfaces.",
    "Implementar hierarquias híbridas que combinam herança e implementação múltipla.",
    "Aplicar padrões de projeto que utilizam interfaces como ponto de extensão."
  ],
  "competencies": [
    "Arquitetura orientada a contratos",
    "Modelagem avançada em Java",
    "Boas práticas de desacoplamento"
  ],
  "skills": [
    "Criar classes abstratas com métodos concretos e abstratos.",
    "Definir interfaces com `default` e `static methods` quando fizer sentido.",
    "Utilizar injeção de dependências baseada em interfaces em serviços de aplicação."
  ],
  "outcomes": [
    "Mapa de decisão para escolha entre classe abstrata e interface.",
    "Protótipo com implementação de contrato para meios de pagamento.",
    "Checklist de conformidade com princípios SOLID."
  ],
  "prerequisites": [
    "Dominar herança e polimorfismo (aulas 05 e 06).",
    "Conhecer tratamento de exceções básico."
  ],
  "tags": ["poo", "interfaces", "java"],
  "duration": 125,
  "modality": "in-person",
  "resources": [
    {
      "label": "Cheatsheet: Padrões com interfaces",
      "type": "supplement",
      "url": "https://edu.local/courses/lpoo/supplements/patterns-cheatsheet"
    },
    {
      "label": "Artigo: Interfaces vs Classes Abstratas",
      "type": "article",
      "url": "https://www.baeldung.com/java-abstract-class-vs-interface"
    },
    {
      "label": "Guia oficial sobre interfaces funcionais",
      "type": "documentation",
      "url": "https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html"
    }
  ],
  "bibliography": [
    "SONMEZ, Y. Java 17 Recipes. Apress, 2023.",
    "FREEMAN, E.; FREEMAN, E. Head First Design Patterns. 3. ed. O'Reilly, 2021."
  ],
  "assessment": {
    "type": "practice",
    "description": "Implementação de um gateway de pagamento pluggable usando interfaces e classes abstratas para provedores.",
    "rubric": "Arquitetura permite inclusão de novos provedores sem alterar código existente e testes demonstram o contrato."
  },
  "content": [
    {
      "type": "lessonPlan",
      "title": "Plano da aula",
      "unit": {
        "title": "Unidade II — Contratos e extensões",
        "content": "Criar contratos reutilizáveis que suportam múltiplas implementações."
      },
      "cards": [
        {
          "icon": "target",
          "title": "Comparativo",
          "content": "Critérios objetivos para escolher entre classe abstrata e interface."
        },
        {
          "icon": "gears",
          "title": "Extensibilidade",
          "content": "Modelar integrações com provedores via interfaces."
        },
        {
          "icon": "cpu",
          "title": "Padrões",
          "content": "Aplicar Template Method e Strategy."
        }
      ]
    },
    {
      "type": "flightPlan",
      "title": "Plano de voo (2h05)",
      "items": [
        "(15 min) Aquecimento com quiz sobre polimorfismo.",
        "(25 min) Exposição dialogada: sintaxe e usos de classes abstratas.",
        "(25 min) Oficina: implementando interfaces para meios de pagamento.",
        "(20 min) Estudo de caso: Template Method com classe abstrata.",
        "(20 min) Pair programming: Strategy com interfaces.",
        "(20 min) Rodada de feedback e registro de mapa de decisão."
      ]
    },
    {
      "type": "callout",
      "variant": "info",
      "title": "Pergunta orientadora",
      "content": [
        {
          "type": "paragraph",
          "text": "O que muda quando você precisa suportar múltiplas implementações de um comportamento sem compartilhar estado?"
        }
      ]
    },
    {
      "type": "cardGrid",
      "title": "Comparativo rápido",
      "columns": 2,
      "cards": [
        {
          "title": "Classe abstrata",
          "subtitle": "Herança simples",
          "tone": "neutral",
          "content": "Permite compartilhar estado e parte da implementação."
        },
        {
          "title": "Interface",
          "subtitle": "Implementação múltipla",
          "tone": "info",
          "content": "Define contratos puros; pode conter métodos `default` e `static`."
        },
        {
          "title": "Quando usar classe abstrata",
          "tone": "warning",
          "content": "Quando existe comportamento comum e você precisa proteger invariantes."
        },
        {
          "title": "Quando usar interface",
          "tone": "success",
          "content": "Quando classes não relacionadas compartilham um conjunto de operações."
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "Template Method x Strategy",
      "content": [
        {
          "type": "paragraph",
          "text": "Ambos se apoiam em polimorfismo, porém Template Method utiliza uma classe abstrata com passos fixos, enquanto Strategy delega para interfaces."
        },
        {
          "component": "OrderedList",
          "props": {
            "items": [
              {
                "title": "Template Method",
                "text": "Classe abstrata define esqueleto e delega passos específicos para subclasses."
              },
              {
                "title": "Strategy",
                "text": "Interface define contrato e objetos injetados implementam variações."
              }
            ]
          }
        }
      ]
    },
    {
      "type": "component",
      "component": "Md3Flowchart",
      "props": {
        "title": "Decisão: classe abstrata ou interface?",
        "nodes": [
          {
            "id": "start",
            "type": "start",
            "title": "Novo comportamento compartilhado"
          },
          {
            "id": "estado",
            "type": "decision",
            "title": "Precisa compartilhar estado?",
            "branches": [
              {
                "id": "sim",
                "label": "Sim",
                "target": "classe"
              },
              {
                "id": "nao",
                "label": "Não",
                "target": "multiplas"
              }
            ]
          },
          {
            "id": "classe",
            "type": "process",
            "title": "Utilize classe abstrata"
          },
          {
            "id": "multiplas",
            "type": "decision",
            "title": "Precisa de múltiplas implementações em classes sem relação?",
            "branches": [
              {
                "id": "sim2",
                "label": "Sim",
                "target": "interface"
              },
              {
                "id": "nao2",
                "label": "Não",
                "target": "avaliar"
              }
            ]
          },
          {
            "id": "interface",
            "type": "process",
            "title": "Defina interface com métodos necessários"
          },
          {
            "id": "avaliar",
            "type": "process",
            "title": "Reavalie com composição ou refatoração"
          },
          {
            "id": "end",
            "type": "end",
            "title": "Contrato decidido"
          }
        ],
        "connections": [
          {
            "from": "start",
            "to": "estado"
          },
          {
            "from": "estado",
            "to": "classe",
            "label": "Sim"
          },
          {
            "from": "estado",
            "to": "multiplas",
            "label": "Não"
          },
          {
            "from": "classe",
            "to": "end"
          },
          {
            "from": "multiplas",
            "to": "interface",
            "label": "Sim"
          },
          {
            "from": "multiplas",
            "to": "avaliar",
            "label": "Não"
          },
          {
            "from": "interface",
            "to": "end"
          },
          {
            "from": "avaliar",
            "to": "end"
          }
        ]
      }
    },
    {
      "type": "checklist",
      "title": "Critérios SOLID",
      "items": [
        "Cada classe ou interface possui uma única responsabilidade?",
        "O contrato aberto para extensão evita modificações em código existente?",
        "Dependo de abstrações em vez de implementações concretas?",
        "Interfaces estão coesas e sem métodos inúteis?"
      ]
    }
  ],
  "metadata": {
    "status": "in-review",
    "updatedAt": "2025-02-01T00:00:00.000Z",
    "owners": ["Prof. Tiago Sombra"],
    "sources": ["Plano de ensino LPOO 2025.2", "Workshop SOLID 2023"]
  }
}
