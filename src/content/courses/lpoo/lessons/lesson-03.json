{
  "formatVersion": "md3.lesson.v1",
  "id": "lesson-03",
  "title": "Aula 3: Objetos, Atributos e Métodos",
  "summary": "Aprofunda o conceito de classes, construtores e encapsulamento de estado/comportamento em objetos Java.",
  "objective": "Construir classes coesas com atributos privados e métodos públicos que expressem regras do domínio.",
  "objectives": [
    "Diferenciar atributos de instância, atributos estáticos e constantes.",
    "Implementar construtores e métodos que validam o estado do objeto.",
    "Aplicar sobrecarga de métodos para criar APIs mais expressivas."
  ],
  "competencies": [
    "Modelagem de domínio orientada a objetos",
    "Domínio de sintaxe Java intermediária",
    "Aplicação de boas práticas de encapsulamento"
  ],
  "skills": [
    "Criar e inicializar objetos com construtores significativos.",
    "Aplicar modificadores de acesso e métodos `getter/setter` quando necessários.",
    "Utilizar `this` e `static` de maneira apropriada."
  ],
  "outcomes": [
    "Classe modelada com testes rápidos no console.",
    "Tabela comparativa de membros de instância x estáticos.",
    "Checklist de boas práticas para criação de métodos."
  ],
  "prerequisites": [
    "Projeto Java configurado na aula anterior.",
    "Conhecimento sobre tipos primitivos e operadores básicos."
  ],
  "tags": ["poo", "java", "classes"],
  "duration": 110,
  "modality": "in-person",
  "resources": [
    {
      "label": "Plano de ensino LPOO 2025.2",
      "type": "document",
      "url": "https://example.edu/lpoo/plano-ensino-2025-2"
    },
    {
      "label": "Deitel & Deitel — Java Como Programar (cap. 3)",
      "type": "book",
      "url": "https://www.pearson.com/en-us/subject-catalog/p/java-how-to-program/P200000000934/9781292402067"
    },
    {
      "label": "Goodrich, Tamassia & Goldwasser — Data Structures and Algorithms in Java (cap. 2)",
      "type": "book",
      "url": "https://www.wiley.com/en-us/Data+Structures+and+Algorithms+in+Java%2C+7th+Edition-p-9781119498590"
    },
    {
      "label": "Herbert Schildt — Java: A Beginner's Guide (cap. 4)",
      "type": "book",
      "url": "https://www.mhprofessional.com/java-a-beginners-guide-eighth-edition-9781260440218-usa"
    },
    {
      "label": "Documentação oficial: Classes e Objetos",
      "type": "article",
      "url": "https://docs.oracle.com/javase/tutorial/java/javaOO/classes.html"
    },
    {
      "label": "Guia sobre sobrecarga de métodos",
      "type": "article",
      "url": "https://www.baeldung.com/java-method-overloading"
    },
    {
      "label": "Deitel LiveLessons – Classes, Objetos e Métodos em Java",
      "type": "video",
      "url": "https://www.youtube.com/watch?v=4ebq0YPHTfQ",
      "duration": "PT28M36S",
      "studyObjective": "Observar uma implementação guiada de classes e métodos segundo as boas práticas apresentadas por Paul Deitel."
    }
  ],
  "bibliography": [
    "SIERRA, K.; BATES, B. Head First Java. 3. ed. O'Reilly, 2022.",
    "FOWLER, M. UML Distilled. 4. ed. Addison-Wesley, 2021."
  ],
  "assessment": {
    "type": "practice",
    "description": "Implementação da classe `Cliente` com validações, construtores sobrecarregados e testes manuais no console.",
    "rubric": "Atributos privados com validação, métodos nomeados com verbos no infinitivo e testes cobrindo cenários positivos/negativos."
  },
  "content": [
    {
      "type": "lessonPlan",
      "title": "Plano da aula",
      "unit": {
        "title": "Unidade I — Estruturação de classes",
        "content": "Explorar como atributos e métodos colaboram para representar conceitos do domínio e garantir invariantes."
      },
      "cards": [
        {
          "icon": "users",
          "title": "Modelagem",
          "content": "Identificar responsabilidades de uma classe e suas interações com o restante do sistema."
        },
        {
          "icon": "check-circle",
          "title": "Integridade",
          "content": "Aplicar encapsulamento para proteger regras de negócio e evitar estados inválidos."
        },
        {
          "icon": "tasks",
          "title": "Sobrecarga",
          "content": "Demonstrar como métodos sobrecarregados oferecem APIs flexíveis sem duplicar lógica."
        }
      ]
    },
    {
      "type": "flightPlan",
      "title": "Plano de voo (1h50)",
      "items": [
        "(15 min) Revisão rápida de classes e objetos.",
        "(25 min) Oficina guiada: construindo a classe `Cliente` passo a passo.",
        "(20 min) Discussão sobre atributos estáticos e contador de instâncias.",
        "(20 min) Exercício prático: sobrecarga de construtores.",
        "(20 min) Pair programming: validar estado e lançar exceções personalizadas.",
        "(10 min) Reflexão e próximos passos."
      ]
    },
    {
      "type": "cardGrid",
      "title": "Tipos de membros em uma classe",
      "columns": 2,
      "cards": [
        {
          "title": "Atributos de instância",
          "subtitle": "Estado individual",
          "tone": "info",
          "content": "Cada objeto armazena o seu próprio valor. Ideal para dados que mudam por instância."
        },
        {
          "title": "Atributos estáticos",
          "subtitle": "Estado compartilhado",
          "tone": "neutral",
          "content": "Pertencem à classe como um todo. Úteis para contadores e cache de configuração."
        },
        {
          "title": "Métodos de instância",
          "subtitle": "Comportamentos dependem do estado",
          "tone": "success",
          "content": "Acessam atributos do objeto atual via `this`."
        },
        {
          "title": "Métodos estáticos",
          "subtitle": "Utilidades ou fábricas",
          "tone": "warning",
          "content": "Executados sem precisar de objeto; não acessam `this` e devem ser usados com parcimônia."
        }
      ]
    },
    {
      "type": "comparativeTable",
      "title": "Comparativo de membros de classe",
      "caption": "Resumo para orientar a escolha entre atributos e métodos de instância, estáticos e constantes.",
      "leadingColumnLabel": "Tipo de membro",
      "headers": ["Escopo", "Vantagens", "Cuidados", "Exemplos"],
      "rows": [
        {
          "label": "Atributo de instância",
          "values": [
            "Cada objeto possui sua própria cópia, acessada via `this`.",
            "Modela o estado específico de cada entidade e permite encapsular regras por objeto.",
            "Evite expor diretamente; valide no construtor e mantenha privado com `getters/setters` coerentes.",
            "`Cliente.nome`, `Pedido.valorTotal`"
          ]
        },
        {
          "label": "Método de instância",
          "values": [
            "Executado sobre um objeto concreto e pode acessar atributos de instância.",
            "Combina estado e comportamento, garantindo invariantes por meio de validações.",
            "Nomeie com verbos claros e mantenha o tamanho reduzido para preservar a coesão.",
            "`cliente.atualizarEndereco()`, `pedido.calcularLimite()`"
          ]
        },
        {
          "label": "Atributo estático",
          "values": [
            "Compartilhado por todas as instâncias da classe.",
            "Centraliza dados comuns como contadores ou configurações cacheadas.",
            "Sincronize atualizações quando houver acesso concorrente e evite armazenar estado mutável desnecessário.",
            "`Cliente.totalClientes`, `Pedido.TAXA_PADRAO`"
          ]
        },
        {
          "label": "Método estático",
          "values": [
            "Chamado diretamente pela classe, sem depender de um objeto.",
            "Útil para fábricas controladas ou utilidades puras que não dependem de estado.",
            "Não acessar atributos de instância; se precisar de estado, considere mover para um método de instância.",
            "`Cliente.novoComCpf(...)`, `Math.max(...)`"
          ]
        },
        {
          "label": "Constante",
          "values": [
            "Geralmente `static final`, permanece imutável para toda a aplicação.",
            "Evita números mágicos e garante consistência para valores invariantes.",
            "Use nomes em maiúsculas e não derive o valor de lógica complexa em tempo de execução.",
            "`Cliente.LIMITE_PADRAO`, `LocalDate.MIN`"
          ]
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "Designando responsabilidades",
      "content": [
        {
          "type": "paragraph",
          "text": "Antes de escrever código, defina claramente o que a classe deve conhecer e fazer. Evite classes anêmicas e métodos gigantes."
        },
        {
          "component": "OrderedList",
          "props": {
            "items": [
              {
                "title": "Nomeie com substantivos",
                "text": "Classes representam conceitos (ex.: `Cliente`, `Pedido`)."
              },
              {
                "title": "Escolha atributos relevantes",
                "text": "Pergunte-se: o objeto realmente precisa armazenar esse dado?"
              },
              {
                "title": "Declare comportamentos",
                "text": "Métodos expressam ações (ex.: `atualizarEndereco`, `calcularLimite`)."
              },
              {
                "title": "Valide invariantes",
                "text": "Construtores devem impedir estados inválidos e lançar exceções significativas."
              }
            ]
          }
        }
      ]
    },
    {
      "type": "component",
      "component": "Md3CodeSample",
      "props": {
        "title": "Classe Cliente validada etapa a etapa",
        "summary": "Retoma a oficina guiada, mostrando como cada sobrecarga garante os requisitos discutidos em sala enquanto mantém o encapsulamento.",
        "language": "java",
        "code": "import java.time.LocalDate;\nimport java.util.Objects;\nimport java.util.regex.Pattern;\n\npublic class Cliente {\n    private static final Pattern EMAIL_PATTERN =\n            Pattern.compile(\"^[\\\\w._%+-]+@[\\\\w.-]+\\\\.[A-Za-z]{2,7}$\");\n    private static final int LIMITE_MINIMO = 0;\n    private static final int LIMITE_PADRAO = 1500;\n\n    private final String documento;\n    private final LocalDate dataCadastro;\n    private String nome;\n    private String email;\n    private String telefone;\n    private int limiteCredito;\n\n    // Etapa 1 da oficina: garantir requisitos mínimos antes de abrir o cadastro.\n    public Cliente(String nome, String documento) {\n        this(nome, documento, null, null, LocalDate.now(), LIMITE_PADRAO);\n    }\n\n    // Etapa 2 da oficina: registrar o contato principal aprovado com o time de marketing.\n    public Cliente(String nome, String documento, String email) {\n        this(nome, documento, email, null, LocalDate.now(), LIMITE_PADRAO);\n    }\n\n    // Etapa 3 da oficina: consolidar regras finais validadas com o time de crédito.\n    public Cliente(String nome,\n                   String documento,\n                   String email,\n                   String telefone,\n                   LocalDate dataCadastro,\n                   int limiteCredito) {\n        this.nome = validarNome(nome);\n        this.documento = validarDocumento(documento);\n        this.email = validarEmail(email);\n        this.telefone = limparTelefone(telefone);\n        this.dataCadastro = Objects.requireNonNullElseGet(dataCadastro, LocalDate::now);\n        this.limiteCredito = validarLimite(limiteCredito);\n    }\n\n    public void atualizarContato(String email, String telefone) {\n        // Etapa 4 da oficina: ajustes pós-revisão mantendo encapsulamento.\n        this.email = validarEmail(email);\n        this.telefone = limparTelefone(telefone);\n    }\n\n    public void ajustarLimite(int novoLimite) {\n        this.limiteCredito = validarLimite(novoLimite);\n    }\n\n    public String resumo() {\n        return String.format(\"%s (%s) - contato: %s - limite: %d\",\n                this.nome,\n                this.documento,\n                this.email == null ? \"pendente\" : this.email,\n                this.limiteCredito);\n    }\n\n    private String validarNome(String nome) {\n        Objects.requireNonNull(nome, \"Nome obrigatório\");\n        String ajustado = nome.trim();\n        if (ajustado.length() < 3) {\n            throw new IllegalArgumentException(\"Nome deve ter ao menos 3 caracteres\");\n        }\n        return ajustado;\n    }\n\n    private String validarDocumento(String documento) {\n        Objects.requireNonNull(documento, \"Documento obrigatório\");\n        String ajustado = documento.replaceAll(\"[^0-9]\", \"\");\n        if (ajustado.length() != 11) {\n            throw new IllegalArgumentException(\"Documento deve conter 11 dígitos\");\n        }\n        return ajustado;\n    }\n\n    private String validarEmail(String email) {\n        if (email == null || email.isBlank()) {\n            return null;\n        }\n        String ajustado = email.trim().toLowerCase();\n        if (!EMAIL_PATTERN.matcher(ajustado).matches()) {\n            throw new IllegalArgumentException(\"E-mail inválido\");\n        }\n        return ajustado;\n    }\n\n    private String limparTelefone(String telefone) {\n        if (telefone == null || telefone.isBlank()) {\n            return null;\n        }\n        return telefone.replaceAll(\"[^0-9]\", \"\");\n    }\n\n    private int validarLimite(int limite) {\n        if (limite < LIMITE_MINIMO) {\n            throw new IllegalArgumentException(\"Limite de crédito não pode ser negativo\");\n        }\n        return limite == 0 ? LIMITE_PADRAO : limite;\n    }\n}\n",
        "highlights": [
          "Construtores encadeados usam this(...) para reaproveitar validações e alinhar-se às etapas da oficina.",
          "Métodos privados reforçam encapsulamento ao centralizar regras de negócio e lançar exceções claras.",
          "Comentários conectam cada sobrecarga às decisões da dinâmica, mostrando a evolução do modelo."
        ]
      }
    },
    {
      "type": "codeChallenge",
      "title": "Escolha a melhor sobrecarga",
      "prompt": "A mesma classe `Cliente` da oficina foi incorporada à API de cadastro. Cada construtor representa uma etapa do fluxo: pré-cadastro (nome e documento), validação de contato principal e aprovação de crédito com limite personalizado. Analise o trecho a seguir e avalie qual assinatura traduz melhor o cenário pedido pelo time.",
      "language": "java",
      "code": "public class Cliente {\n    private static final int LIMITE_PADRAO = 1500;\n\n    public Cliente(String nome, String documento) {\n        this(nome, documento, null, LIMITE_PADRAO);\n    }\n\n    public Cliente(String nome, String documento, String email) {\n        this(nome, documento, email, LIMITE_PADRAO);\n    }\n\n    public Cliente(String nome, String documento, String email, int limiteCredito) {\n        // Validações detalhadas omitidas\n    }\n}\n",
      "question": "Durante a etapa final da oficina, o comitê de crédito envia nome, documento, e-mail validado e um limite específico negociado com o cliente. Qual sobrecarga atende melhor a esse cenário sem perder as validações encapsuladas?",
      "options": [
        {
          "id": "a",
          "text": "new Cliente(nome, documento) — etapa de pré-cadastro apenas com campos mínimos."
        },
        {
          "id": "b",
          "text": "new Cliente(nome, documento, email) — etapa de confirmação de contato com limite padrão."
        },
        {
          "id": "c",
          "text": "new Cliente(nome, documento, email, limiteNegociado) — etapa de crédito personalizada."
        }
      ],
      "answerExplanation": "A sobrecarga com quatro parâmetros permite registrar o limite negociado imediatamente, mantendo o reuso das validações internas e honrando o encapsulamento discutido na oficina. As outras versões foram pensadas para etapas anteriores, nas quais o limite ainda é padrão ou inexistente."
    },
    {
      "type": "component",
      "component": "Md3BlockDiagram",
      "props": {
        "title": "Colaboração entre objetos",
        "summary": "Exemplo de relacionamento entre classes do domínio Varejo.",
        "blocks": [
          {
            "id": "cliente",
            "title": "Cliente",
            "summary": "Dados cadastrais",
            "layer": 1,
            "kind": "process"
          },
          {
            "id": "pedido",
            "title": "Pedido",
            "summary": "Itens e pagamentos",
            "layer": 2,
            "kind": "process"
          },
          {
            "id": "pagamento",
            "title": "Pagamento",
            "summary": "Transações e recibos",
            "layer": 3,
            "kind": "data-store"
          },
          {
            "id": "email",
            "title": "Serviço de E-mail",
            "summary": "Confirmações",
            "layer": 4,
            "kind": "external"
          }
        ],
        "channels": [
          {
            "id": "c1",
            "from": "cliente",
            "to": "pedido",
            "description": "Cliente cria pedidos e adiciona itens",
            "kind": "control"
          },
          {
            "id": "c2",
            "from": "pedido",
            "to": "pagamento",
            "description": "Pedido calcula total e inicia cobrança",
            "kind": "data"
          },
          {
            "id": "c3",
            "from": "pedido",
            "to": "email",
            "description": "Pedido envia confirmação ao cliente",
            "kind": "feedback"
          }
        ],
        "legend": [
          {
            "id": "process",
            "label": "Objeto de domínio",
            "description": "Entidades que concentram regras de negócio."
          },
          {
            "id": "data-store",
            "label": "Persistência",
            "description": "Objetos que garantem armazenamento e histórico."
          },
          {
            "id": "external",
            "label": "Serviço externo",
            "description": "Infraestrutura fora da aplicação."
          },
          {
            "id": "control",
            "label": "Ação",
            "description": "Mensagens que orquestram fluxos."
          }
        ]
      }
    }
  ],
  "metadata": {
    "status": "in-review",
    "updatedAt": "2025-10-03T00:00:00.000Z",
    "owners": ["Prof. Tiago Sombra"],
    "sources": [
      "Plano de ensino LPOO 2025.2",
      "docs/governance/faculty-review-sessions.md – Semana 3 (LPOO)"
    ]
  }
}
