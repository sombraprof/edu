{
  "id": "lesson7",
  "title": "Aula 7: Interfaces e Classes Abstratas",
  "objective": "",
  "content": [
    {
      "type": "legacySection",
      "id": "ementa",
      "title": "Ementa e Contextualiza√ß√£o",
      "html": "<p> At√© agora, trabalhamos com classes concretas, que podem ser instanciadas diretamente. No entanto, ao modelar sistemas complexos, muitas vezes precisamos de um n√≠vel maior de abstra√ß√£o. As <strong>classes abstratas</strong> nos permitem criar \"modelos\" de classes incompletas, for√ßando as subclasses a fornecerem implementa√ß√µes espec√≠ficas. J√° as <strong>interfaces</strong> levam a abstra√ß√£o a um novo patamar, definindo \"contratos\" de comportamento que classes completamente diferentes podem seguir. Dominar esses dois conceitos √© crucial para projetar sistemas desacoplados, flex√≠veis e que seguem os princ√≠pios de design SOLID. </p>"
    },
    {
      "type": "legacySection",
      "id": "plano-aula",
      "title": "Plano da Aula",
      "html": "<div data-legacy-grid=\"\"> <div data-legacy-card=\"\"> <h3> <span class=\"legacy-section__icon\" aria-hidden=\"true\" data-legacy-icon=\"book-open\">üìñ</span>CONTE√öDO </h3> <p> Classes Abstratas, M√©todos Abstratos, Interfaces, palavra-chave <code-text>implements</code-text>, e a diferen√ßa entre os dois conceitos. </p> </div> <div data-legacy-card=\"\"> <h3> <span class=\"legacy-section__icon\" aria-hidden=\"true\" data-legacy-icon=\"bullseye\">üéØ</span>OBJETIVO </h3> <p> Capacitar o aluno a projetar e implementar hierarquias de classes flex√≠veis usando classes abstratas e a definir contratos com interfaces. </p> </div> <div data-legacy-card=\"\"> <h3> <span class=\"legacy-section__icon\" aria-hidden=\"true\" data-legacy-icon=\"gears\">‚öôÔ∏è</span>METODOLOGIA </h3> <p> Aula expositiva, exemplos comparativos de c√≥digo, uma tabela de diferen√ßas e uma atividade pr√°tica de modelagem de sistema. </p> </div> </div> <div data-legacy-card=\"\"> <h3>Exemplo 3: Conflito de <code-text>default</code-text> em M√∫ltiplas Interfaces</h3> <p>Quando duas interfaces definem o mesmo m√©todo <code-text>default</code-text>, a classe precisa resolver o conflito explicitamente.</p> <div> <button data-tooltip=\"Copiar c√≥digo\" aria-label=\"Copiar c√≥digo de m√∫ltiplas interfaces com default\">Copiar</button> <pre><code>interface A { default void log() { System.out.println(\"A\"); } }\ninterface B { default void log() { System.out.println(\"B\"); } } class C implements A, B { @Override // Must resolve the conflict explicitly public void log() { A.super.log(); // or B.super.log(); or custom logic System.out.println(\"C\"); }\n} </code></pre> </div> </div> <div data-legacy-card=\"\"> <h3>Extras Modernos: Hierarquias <em>sealed</em> (Java 17+)</h3> <p>Interfaces e classes podem ser seladas para restringir quem pode implement√°-las/herd√°-las.</p> <div> <button data-tooltip=\"Copiar c√≥digo\" aria-label=\"Copiar c√≥digo de sealed interfaces\">Copiar</button> <pre><code>public sealed interface Voavel permits Passaro, Aviao { void voar();\n} public final class Passaro implements Voavel { // final: cannot be subclassed further @Override public void voar() { System.out.println(\"Batendo asas\"); }\n} public non-sealed class Aviao implements Voavel { @Override public void voar() { System.out.println(\"Turbinas ligadas\"); }\n} </code></pre> </div> </div>"
    },
    {
      "type": "legacySection",
      "id": "teoria",
      "title": "üìú Definindo Contratos e Modelos",
      "html": "<div data-legacy-card=\"\"> <h3> 1. Classes Abstratas: O Modelo Incompleto </h3> <p> Uma classe abstrata √© uma classe que <strong>n√£o pode ser instanciada</strong>. Ela serve como um modelo base para outras classes. Pode conter tanto m√©todos concretos (com implementa√ß√£o) quanto m√©todos abstratos (sem implementa√ß√£o). </p> <ul> <li> <strong>Palavra-chave <code-text>abstract</code-text>:</strong> Usada para declarar tanto a classe quanto os m√©todos abstratos. </li> <li> <strong>M√©todos Abstratos:</strong> S√£o como uma promessa. Eles declaram uma assinatura de m√©todo, mas sem corpo. Qualquer classe concreta que herda da classe abstrata √© <strong>obrigada</strong> a implementar todos os m√©todos abstratos. </li> <li> <strong>Quando usar?</strong> Quando voc√™ tem uma rela√ß√£o \"√©-um\" (heran√ßa) e quer fornecer um comportamento base comum para todas as subclasses, mas ao mesmo tempo for√ßar que cada uma delas implemente uma parte espec√≠fica do comportamento. </li> </ul> </div> <div data-legacy-card=\"\"> <h3> 2. Interfaces: O Contrato de Comportamento </h3> <p> Uma interface √© uma refer√™ncia de tipo completamente abstrata. Ela s√≥ pode conter assinaturas de m√©todos e constantes (<code-text>public static final</code-text>). Uma classe pode <strong>implementar</strong> uma ou mais interfaces. </p> <ul> <li> <strong>Palavra-chave <code-text>interface</code-text> e <code-text>implements</code-text>:</strong> <code-text>interface</code-text> para declarar e <code-text>implements</code-text> para uma classe implementar a interface. </li> <li> <strong>100% Abstrata (antes do Java 8):</strong> Todos os m√©todos s√£o implicitamente <code-text>public</code-text> e <code-text>abstract</code-text>. Todos os atributos s√£o <code-text>public static final</code-text>. </li> <li> <strong>Quando usar?</strong> Quando voc√™ quer definir um \"contrato\" de comportamento que pode ser implementado por classes de diferentes hierarquias. √â a base para um design de software desacoplado e a forma como Java simula a \"heran√ßa m√∫ltipla\". </li> </ul> </div> <div data-legacy-card=\"\"> <h3> Classe Abstrata vs. Interface </h3> <div> <table> <thead> <tr> <th scope=\"col\">Caracter√≠stica</th> <th scope=\"col\">Classe Abstrata</th> <th scope=\"col\">Interface (Java 8+)</th> </tr> </thead> <tbody> <tr> <th scope=\"row\"> Instancia√ß√£o </th> <td>N√£o pode ser instanciada; pode ter construtor (chamado via <code-text>super()</code-text>).</td> <td>N√£o pode ser instanciada; sem construtor.</td> </tr> <tr> <th scope=\"row\"> M√©todos </th> <td> Pode ter m√©todos abstratos e concretos. </td> <td> Abstratos, <strong>default</strong>, <strong>static</strong> e (Java 9+) <strong>private</strong>. </td> </tr> <tr> <th scope=\"row\"> Atributos/Estado </th> <td> Pode ter qualquer tipo de atributo (static, final, non-final). </td> <td> S√≥ pode ter constantes (<code-text>public static final</code-text>). </td> </tr> <tr> <th scope=\"row\"> Heran√ßa </th> <td> Uma classe pode herdar de apenas <strong>uma</strong> classe abstrata (<code-text>extends</code-text>). </td> <td> Pode <code-text>extends</code-text> m√∫ltiplas interfaces (heran√ßa m√∫ltipla de tipo). </td> </tr> <tr> <th scope=\"row\"> Construtor </th> <td> Pode ter construtores (chamados via <code-text>super()</code-text> pelas subclasses). </td> <td>N√£o pode ter construtores.</td> </tr> <tr> <th scope=\"row\"> Prop√≥sito </th> <td> Definir um modelo base com comportamento comum para uma hierarquia (rela√ß√£o \"√©-um\"). </td> <td> Definir um contrato de capacidades que podem ser compartilhadas por classes n√£o relacionadas. </td> </tr> <tr> <th scope=\"row\"> Extras modernos </th> <td>Pode ser <em>sealed</em> (Java 17+) para controlar subclasses.</td> <td>Conflitos de <code-text>default</code-text>; <code-text>@FunctionalInterface</code-text>; tamb√©m pode ser <em>sealed</em>.</td> </tr> </tbody> </table> </div> </div>"
    },
    {
      "type": "legacySection",
      "id": "pratica",
      "title": "üíª Abstra√ß√£o na Pr√°tica",
      "html": "<div data-legacy-card=\"\"> <h3> Exemplo 1: Classe Abstrata <code-text>FormaGeometrica</code-text> </h3> <p> <code-text>FormaGeometrica</code-text> define o conceito de \"√°rea\", mas n√£o sabe como calcul√°-la. <code-text>Retangulo</code-text> e <code-text>Circulo</code-text> s√£o obrigados a fornecer a f√≥rmula. </p> <div> <button data-tooltip=\"Copiar c√≥digo\" aria-label=\"Copiar c√≥digo da classe abstrata FormaGeometrica e subclasses\"> Copiar </button> <pre><code>// Abstract base class with state and constructor\npublic abstract class FormaGeometrica { private final String nome; public FormaGeometrica(String nome) { this.nome = nome; } public String getNome() { // Exposes read-only state return nome; } public abstract double calcularArea(); // Must be implemented by subclasses\n} public class Retangulo extends FormaGeometrica { private final double largura; private final double altura; public Retangulo(double largura, double altura) { super(\"Retangulo\"); this.largura = largura; this.altura = altura; } @Override public double calcularArea() { return largura * altura; }\n} public class Circulo extends FormaGeometrica { private final double raio; public Circulo(double raio) { super(\"Circulo\"); this.raio = raio; } @Override public double calcularArea() { return Math.PI * raio * raio; }\n} </code></pre> </div> </div> <div data-legacy-card=\"\"> <h3> Exemplo 2: Interface <code-text>Tributavel</code-text> </h3> <p> Tanto uma <code-text>ContaCorrente</code-text> quanto um <code-text>SeguroDeVida</code-text> podem ser tribut√°veis, mas n√£o t√™m uma rela√ß√£o de heran√ßa. A interface <code-text>Tributavel</code-text> cria um contrato comum. </p> <div> <button data-tooltip=\"Copiar c√≥digo\" aria-label=\"Copiar c√≥digo da interface Tributavel e implementa√ß√µes\"> Copiar </button> <pre><code>// Contract for taxable entities (Java 8+ features demonstrated)\npublic interface Tributavel { double getValorImposto(); // Abstract method (must be implemented) default double aplicarAcrescimo(double valor) { // Default method provides reusable behavior for implementors return valor + calcularAcrescimo(valor); } private double calcularAcrescimo(double valor) { // Java 9+ private reuse return valor * 0.02; // 2% extra fee as an example } static double arredonda(double v) { // Utility static method return Math.round(v * 100.0) / 100.0; }\n} // Simple account (educational)\nclass Conta { private double saldo; public Conta(double saldo) { this.saldo = saldo; } public double getSaldo() { return saldo; }\n} class ContaCorrente extends Conta implements Tributavel { public ContaCorrente(double saldo) { super(saldo); } @Override public double getValorImposto() { return getSaldo() * 0.01; // 1% of balance }\n} class SeguroDeVida implements Tributavel { @Override public double getValorImposto() { return 42.0; // fixed tax }\n} import java.util.List; class CalculadoraImpostos { public static void main(String[] args) { // Polymorphism with interfaces: unrelated classes share a contract List<tributavel> itens = List.of( new ContaCorrente(2500.0), new SeguroDeVida() ); double total = 0; for (Tributavel t : itens) { double base = t.getValorImposto(); // Using default + static methods from the interface double comAcrescimo = Tributavel.arredonda(t.aplicarAcrescimo(base)); total += comAcrescimo; System.out.println(\"Item -&gt; imposto: \" + comAcrescimo); } System.out.println(\"Total: \" + Tributavel.arredonda(total)); }\n} </tributavel></code></pre> </div> </div>"
    },
    {
      "type": "legacySection",
      "id": "recursos-auxiliares",
      "title": "üé• V√≠deos e Links de Apoio",
      "html": "<div data-legacy-grid=\"\"> <div data-legacy-card=\"\"> <h3> Classes Abstratas (Curso em V√≠deo) </h3> <div> </div> </div> <div data-legacy-card=\"\"> <h3> Interfaces em Java (Loiane Groner) </h3> <div> </div> </div> <div data-legacy-card=\"\"> <h3> Leituras Recomendadas </h3> <ul> <li> <a href=\"https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html\" target=\"_blank\" rel=\"noopener noreferrer\"> <span class=\"legacy-section__icon\" aria-hidden=\"true\" data-legacy-icon=\"book-bookmark\">üìò</span>Abstract Methods and Classes (Oracle) </a> <p> A documenta√ß√£o oficial sobre classes e m√©todos abstratos. </p> </li> <li> <a href=\"https://www.baeldung.com/java-interfaces\" target=\"_blank\" rel=\"noopener noreferrer\"> Java Interfaces (Baeldung) </a> <p> Um guia t√©cnico completo sobre o uso de interfaces em Java. </p> </li> </ul> </div> </div>"
    },
    {
      "type": "legacySection",
      "id": "ted",
      "title": "Atividade Pr√°tica (TED): Modelando um Zool√≥gico",
      "html": "<p> Vamos projetar um sistema simples para um zool√≥gico, combinando classes abstratas e interfaces. </p> <ol> <li> <strong>Crie a classe abstrata <code-text>Animal.java</code-text></strong>. Ela deve ter um atributo <code-text>nome</code-text> e um m√©todo abstrato <code-text>public abstract void emitirSom()</code-text>. </li> <li> <strong>Crie as classes concretas <code-text>Leao.java</code-text> e <code-text>Passaro.java</code-text></strong>, ambas herdando de <code-text>Animal</code-text>. Implemente o m√©todo <code-text>emitirSom()</code-text> em cada uma (ex: \"Rugido!\" e \"Pio!\"). </li> <li> <strong>Crie a interface <code-text>Voavel.java</code-text></strong>. Ela deve ter um √∫nico m√©todo: <code-text>public void voar()</code-text>. </li> <li> <strong>Fa√ßa a classe <code-text>Passaro</code-text> implementar a interface <code-text>Voavel</code-text></strong> e forne√ßa uma implementa√ß√£o para o m√©todo <code-text>voar()</code-text>. O Le√£o n√£o deve implementar esta interface. </li> <li> <strong>Crie uma classe <code-text>Zoologico.java</code-text> com um m√©todo <code-text>main</code-text></strong>. Crie um <code-text>Leao</code-text> e um <code-text>Passaro</code-text>. Use polimorfismo para chamar <code-text>emitirSom()</code-text> de ambos. Verifique se o p√°ssaro pode voar, mas o le√£o n√£o. </li> </ol>"
    },
    {
      "type": "legacySection",
      "id": "checklist",
      "title": "‚úÖChecklist de Aprendizagem da Aula",
      "html": "<div data-legacy-card=\"\"> <p>Ao final desta aula, voc√™ deve ser capaz de:</p> <ul> <li> <span class=\"legacy-section__icon\" aria-hidden=\"true\" data-legacy-icon=\"check\">‚úîÔ∏è</span>Definir e criar uma classe abstrata com m√©todos abstratos e concretos. </li> <li> <span class=\"legacy-section__icon\" aria-hidden=\"true\" data-legacy-icon=\"check\">‚úîÔ∏è</span>Compreender que classes abstratas n√£o podem ser instanciadas. </li> <li> <span class=\"legacy-section__icon\" aria-hidden=\"true\" data-legacy-icon=\"check\">‚úîÔ∏è</span>Definir e implementar uma interface em uma ou mais classes. </li> <li> <span class=\"legacy-section__icon\" aria-hidden=\"true\" data-legacy-icon=\"check\">‚úîÔ∏è</span>Explicar as diferen√ßas cruciais entre uma classe abstrata e uma interface. </li> <li> <span class=\"legacy-section__icon\" aria-hidden=\"true\" data-legacy-icon=\"check\">‚úîÔ∏è</span>Escolher entre uma classe abstrata e uma interface com base no problema de design. </li> </ul> </div>"
    },
    {
      "type": "legacySection",
      "id": "bibliografia",
      "title": "üìö Bibliografia de Apoio",
      "html": "<div data-legacy-card=\"\"> <p> <strong>DEITEL, Harvey M.; DEITEL, Paul J.</strong> <em>Java: como programar.</em> 8. ed. S√£o Paulo: Pearson Prentice Hall, 2014. </p> <p> <strong>SCHILDT, Herbert.</strong> <em>Java para iniciantes: crie, compile e execute programas Java rapidamente.</em> 6. ed. Porto Alegre: Bookman, 2015. </p> <p> <strong>GOODRICH, Michael T.; TAMASSIA, Roberto.</strong> <em>Estruturas de dados e algoritmos em Java.</em> 5. ed. Porto Alegre: Bookman, 2013. </p> </div>"
    }
  ]
}
