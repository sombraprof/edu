{
  "formatVersion": "md3.lesson.v1",
  "id": "lesson-05",
  "title": "Aula 5: Resolução da AV1 e Introdução à Herança",
  "summary": "Analisa a avaliação diagnóstica da turma, discute padrões de erro e apresenta os fundamentos de herança em Java.",
  "objective": "Consolidar aprendizados da primeira etapa e introduzir reutilização estrutural com herança controlada.",
  "objectives": [
    "Interpretar os resultados da AV1 identificando habilidades dominadas e lacunas prioritárias.",
    "Refatorar uma classe base a partir de requisitos comuns.",
    "Criar subclasses que especializam comportamento com sobrescrita segura."
  ],
  "competencies": [
    "Avaliação diagnóstica de aprendizagem",
    "Modelagem orientada a objetos",
    "Refatoração incremental"
  ],
  "skills": [
    "Aplicar boas práticas de feedback formativo e autoavaliação.",
    "Definir hierarquias simples de classes usando `extends`.",
    "Utilizar `super` para acessar construtores e métodos da superclasse."
  ],
  "outcomes": [
    "Plano de ação individual pós-AV1.",
    "Diagrama simples da hierarquia proposta.",
    "Protótipo de código demonstrando herança e sobrescrita."
  ],
  "prerequisites": [
    "Participação na AV1 e revisão das aulas 01-04.",
    "Conhecimento sobre classes, encapsulamento e métodos."
  ],
  "tags": ["poo", "heranca", "avaliacao"],
  "duration": 120,
  "modality": "in-person",
  "resources": [
    {
      "label": "Relatório consolidado da AV1",
      "type": "document",
      "url": "https://example.edu/lpoo/relatorios/av1"
    },
    {
      "label": "Guia Oracle: Inheritance",
      "type": "article",
      "url": "https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html"
    },
    {
      "label": "Deitel LiveLessons – Introdução à Herança em Java",
      "type": "video",
      "url": "https://www.youtube.com/watch?v=Y2WIDqgqH90",
      "duration": "PT24M44S",
      "studyObjective": "Acompanhar um exemplo completo de reutilização de código com superclasses e subclasses orientado por Paul Deitel."
    },
    {
      "label": "Exemplo completo: hierarquia Funcionario/Analista/Estagiario",
      "type": "repository",
      "url": "https://example.edu/repos/lpoo/heranca-funcionarios"
    }
  ],
  "bibliography": [
    "BARNES, D.; KÖLLING, M. Objects First with Java. 7. ed. Pearson, 2023.",
    "GAMMA, E. et al. Design Patterns. Addison-Wesley, 2021."
  ],
  "assessment": {
    "type": "remediation",
    "description": "Entrega de plano de estudo personalizado e exercício prático de herança submetido ao repositório da disciplina.",
    "rubric": "Plano com metas específicas, código com superclasse reutilizável e testes demonstrando polimorfismo."
  },
  "content": [
    {
      "type": "lessonPlan",
      "title": "Plano da aula",
      "unit": {
        "title": "Unidade II — Reutilização e evolução",
        "content": "Retomar conteúdos da primeira etapa e introduzir herança como mecanismo de extensão."
      },
      "cards": [
        {
          "icon": "database",
          "title": "Análise da AV1",
          "content": "Examinar indicadores por competência e discutir estratégias de reforço."
        },
        {
          "icon": "target",
          "title": "Hierarquias",
          "content": "Entender quando herdar e quando preferir composição."
        },
        {
          "icon": "users",
          "title": "Feedback",
          "content": "Definir ações individuais e coletivas para a próxima sprint."
        }
      ]
    },
    {
      "type": "flightPlan",
      "title": "Plano de voo (2h00)",
      "items": [
        "(20 min) Apresentação dos dados da AV1 e discussão em grupos.",
        "(15 min) Check-in emocional e alinhamento de expectativas.",
        "(30 min) Mini aula: conceitos de herança e reutilização.",
        "(25 min) Exercício guiado: fatorando uma superclasse `Funcionario`.",
        "(20 min) Pair programming: criando subclasses `Analista` e `Estagiario`.",
        "(10 min) Compartilhamento de planos de ação.",
        "(10 min) Orientações sobre tarefa assíncrona."
      ]
    },
    {
      "type": "callout",
      "variant": "info",
      "title": "Pergunta norteadora",
      "content": [
        {
          "type": "paragraph",
          "text": "Qual comportamento realmente precisa ser herdado? Há riscos de dependências rígidas se a hierarquia crescer demais?"
        }
      ]
    },
    {
      "type": "timeline",
      "title": "Indicadores da AV1",
      "steps": [
        {
          "title": "Objetivos atingidos",
          "content": "70% dominaram criação de classes e construtores."
        },
        {
          "title": "Alertas",
          "content": "40% tiveram dificuldades com validação e tratamento de erros."
        },
        {
          "title": "Próximas ações",
          "content": "Oficinas extras sobre encapsulamento e plantão tira-dúvidas."
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "Quando usar herança",
      "content": [
        {
          "type": "paragraph",
          "text": "Herança favorece reutilização de código quando as classes compartilham identidade conceitual. Evite usar apenas para reaproveitar trechos isolados."
        },
        {
          "component": "OrderedList",
          "props": {
            "items": [
              {
                "title": "Compartilhe contrato",
                "text": "Superclasse define métodos que todas as subclasses devem fornecer."
              },
              {
                "title": "Especialize comportamento",
                "text": "Subclasses sobrescrevem métodos para adicionar regras específicas."
              },
              {
                "title": "Evite herança acidental",
                "text": "Se não houver relação `é-um`, prefira composição."
              }
            ]
          }
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "Exemplo comentado de herança em Java",
      "content": [
        {
          "type": "paragraph",
          "text": "Note como a superclasse concentra validações e o estado compartilhado, enquanto as subclasses apenas especializam o cálculo salarial."
        },
        {
          "type": "code",
          "language": "java",
          "code": "public class Funcionario {\n    // Use 'protected' para expor somente o necessário às subclasses mantendo encapsulamento.\n    protected final String nome;\n    protected final double salarioBase;\n\n    public Funcionario(String nome, double salarioBase) {\n        // Valide entradas no construtor para garantir objetos sempre consistentes.\n        if (nome == null || nome.isBlank()) {\n            throw new IllegalArgumentException(\"Nome não pode ser vazio\");\n        }\n        if (salarioBase < 0) {\n            throw new IllegalArgumentException(\"Salário base deve ser não negativo\");\n        }\n        this.nome = nome;\n        this.salarioBase = salarioBase;\n    }\n\n    public String getNome() {\n        return nome;\n    }\n\n    public double calcularSalario() {\n        return salarioBase;\n    }\n}\n\npublic class Analista extends Funcionario {\n    private final double bonusProjeto;\n\n    public Analista(String nome, double salarioBase, double bonusProjeto) {\n        super(nome, salarioBase); // Delegue ao construtor da superclasse sempre que precisar reutilizar validações comuns.\n        if (bonusProjeto < 0) {\n            throw new IllegalArgumentException(\"Bônus deve ser não negativo\");\n        }\n        this.bonusProjeto = bonusProjeto;\n    }\n\n    @Override\n    public double calcularSalario() {\n        return super.calcularSalario() + bonusProjeto;\n    }\n}\n\npublic class Estagiario extends Funcionario {\n    private final int horasSemana;\n\n    public Estagiario(String nome, double salarioBase, int horasSemana) {\n        super(nome, salarioBase); // Chame 'super()' primeiro para garantir que o estado herdado seja inicializado corretamente.\n        if (horasSemana <= 0 || horasSemana > 40) {\n            throw new IllegalArgumentException(\"Horas semanais devem estar entre 1 e 40\");\n        }\n        this.horasSemana = horasSemana;\n    }\n\n    @Override\n    public double calcularSalario() {\n        return super.calcularSalario() * horasSemana / 40.0;\n    }\n}\n\npublic class FolhaPagamento {\n    public static void main(String[] args) {\n        // Rotina rápida de teste para demonstrar polimorfismo e verificar sobrescritas.\n        Funcionario ana = new Analista(\"Ana\", 6000, 1200);\n        Funcionario joao = new Estagiario(\"João\", 2000, 30);\n\n        System.out.printf(\"%s recebe R$ %.2f\\n\", ana.getNome(), ana.calcularSalario());\n        System.out.printf(\"%s recebe R$ %.2f\\n\", joao.getNome(), joao.calcularSalario());\n    }\n}"
        }
      ]
    },
    {
      "type": "component",
      "component": "Md3Flowchart",
      "props": {
        "title": "Fluxo de construção da hierarquia",
        "nodes": [
          {
            "id": "start",
            "type": "start",
            "title": "Identificar características comuns"
          },
          {
            "id": "super",
            "type": "process",
            "title": "Criar superclasse com atributos e métodos compartilhados"
          },
          {
            "id": "decisao",
            "type": "decision",
            "title": "Existe comportamento específico?",
            "branches": [
              {
                "id": "sim",
                "label": "Sim",
                "target": "subclasse"
              },
              {
                "id": "nao",
                "label": "Não",
                "target": "usar"
              }
            ]
          },
          {
            "id": "subclasse",
            "type": "process",
            "title": "Implementar subclass e sobrescrever métodos"
          },
          {
            "id": "usar",
            "type": "output",
            "title": "Instanciar objetos e testar polimorfismo"
          },
          {
            "id": "end",
            "type": "end",
            "title": "Hierarquia validada"
          }
        ],
        "connections": [
          {
            "from": "start",
            "to": "super"
          },
          {
            "from": "super",
            "to": "decisao"
          },
          {
            "from": "decisao",
            "to": "subclasse",
            "label": "Sim"
          },
          {
            "from": "decisao",
            "to": "usar",
            "label": "Não"
          },
          {
            "from": "subclasse",
            "to": "usar"
          },
          {
            "from": "usar",
            "to": "end"
          }
        ]
      }
    }
  ],
  "metadata": {
    "status": "in-review",
    "updatedAt": "2025-02-01T00:00:00.000Z",
    "owners": ["Prof. Tiago Sombra"],
    "sources": ["Relatório AV1 2025.2", "Plano de aula LPOO – módulo 2"]
  }
}
