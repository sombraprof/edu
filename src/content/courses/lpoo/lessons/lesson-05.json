{
  "formatVersion": "md3.lesson.v1",
  "id": "lesson-05",
  "title": "Aula 5: Resolução da AV1 e Introdução à Herança",
  "summary": "Analisa a avaliação diagnóstica da turma, discute padrões de erro e apresenta os fundamentos de herança em Java.",
  "objective": "Consolidar aprendizados da primeira etapa e introduzir reutilização estrutural com herança controlada.",
  "objectives": [
    "Interpretar os resultados da AV1 identificando habilidades dominadas e lacunas prioritárias.",
    "Refatorar uma classe base a partir de requisitos comuns.",
    "Criar subclasses que especializam comportamento com sobrescrita segura."
  ],
  "competencies": [
    "Avaliação diagnóstica de aprendizagem",
    "Modelagem orientada a objetos",
    "Refatoração incremental"
  ],
  "skills": [
    "Aplicar boas práticas de feedback formativo e autoavaliação.",
    "Definir hierarquias simples de classes usando `extends`.",
    "Utilizar `super` para acessar construtores e métodos da superclasse."
  ],
  "outcomes": [
    "Plano de ação individual pós-AV1.",
    "Diagrama simples da hierarquia proposta.",
    "Protótipo de código demonstrando herança e sobrescrita."
  ],
  "prerequisites": [
    "Participação na AV1 e revisão das aulas 01-04.",
    "Conhecimento sobre classes, encapsulamento e métodos."
  ],
  "tags": ["poo", "heranca", "avaliacao"],
  "duration": 150,
  "modality": "in-person",
  "resources": [
    {
      "label": "Guia Oracle: Inheritance",
      "type": "article",
      "url": "https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html"
    },
    {
      "label": "Oracle Academy – Type Inheritance Foundation",
      "type": "video",
      "url": "https://www.youtube.com/watch?v=SA5c_PfPYtI",
      "duration": "PT30M00S",
      "studyObjective": "Revisitar a teoria de herança da Oracle Academy, alinhando `extends`, visibilidade e uso de `super` ao exercício da hierarquia `Funcionario`."
    },
    {
      "label": "Deitel LiveLessons – Introdução à Herança em Java",
      "type": "video",
      "url": "https://www.youtube.com/watch?v=Y2WIDqgqH90",
      "duration": "PT24M44S",
      "studyObjective": "Conectar a análise da AV1 à implementação de `Funcionario`, observando como Paul Deitel refatora superclasses e prepara o terreno para polimorfismo seguro."
    },
    {
      "label": "Opcional — Oracle Developer Live: Herança e Polimorfismo em Profundidade",
      "type": "video",
      "url": "https://www.youtube.com/watch?v=fxQ6jF7zpHg",
      "duration": "PT36M27S",
      "studyObjective": "Aprofundar polimorfismo dinâmico conectado à herança, observando padrões de sobrescrita e LSP para preparar a aula 06."
    }
  ],
  "bibliography": [
    "BARNES, D.; KÖLLING, M. Objects First with Java. 7. ed. Pearson, 2023.",
    "GAMMA, E. et al. Design Patterns. Addison-Wesley, 2021."
  ],
  "assessment": {
    "type": "remediation",
    "description": "Entrega de plano de estudo personalizado e exercício prático de herança submetido ao repositório da disciplina.",
    "rubric": "Plano com metas específicas, código com superclasse reutilizável e testes demonstrando polimorfismo."
  },
  "content": [
    {
      "type": "lessonPlan",
      "title": "Plano da aula",
      "unit": {
        "title": "Unidade II — Reutilização e evolução",
        "content": "Retomar conteúdos da primeira etapa e introduzir herança como mecanismo de extensão."
      },
      "cards": [
        {
          "icon": "database",
          "title": "Análise da AV1",
          "content": "Examinar indicadores por competência e discutir estratégias de reforço."
        },
        {
          "icon": "target",
          "title": "Hierarquias",
          "content": "Entender quando herdar e quando preferir composição."
        },
        {
          "icon": "users",
          "title": "Feedback",
          "content": "Definir ações individuais e coletivas para a próxima sprint."
        }
      ]
    },
    {
      "type": "flightPlan",
      "title": "Plano de voo (2h00)",
      "items": [
        "(20 min) Apresentação dos dados da AV1 e discussão em grupos.",
        "(15 min) Check-in emocional e alinhamento de expectativas.",
        "(30 min) Mini aula: conceitos de herança e reutilização.",
        "(25 min) Exercício guiado: fatorando uma superclasse `Funcionario`.",
        "(20 min) Pair programming: criando subclasses `Analista` e `Estagiario`.",
        "(10 min) Compartilhamento de planos de ação.",
        "(10 min) Orientações sobre tarefa assíncrona."
      ]
    },
    {
      "type": "timeline",
      "title": "Indicadores da AV1",
      "steps": [
        {
          "title": "Objetivos atingidos",
          "content": "70% dominaram criação de classes e construtores."
        },
        {
          "title": "Alertas",
          "content": "40% tiveram dificuldades com validação e tratamento de erros."
        },
        {
          "title": "Próximas ações",
          "content": "Oficinas extras sobre encapsulamento e plantão tira-dúvidas."
        }
      ]
    },
    {
      "type": "component",
      "component": "SelfAssessment",
      "props": {
        "title": "Plano de ação pós-AV1",
        "description": "Registre compromissos individuais com base no feedback formativo: identifique pontos fortes, lacunas prioritárias e estratégias para evoluir até a AV2.",
        "prompts": [
          {
            "id": "diagnostico-pessoal",
            "label": "Qual é o diagnóstico pessoal sobre seus resultados na AV1?",
            "placeholder": "Liste evidências dos seus acertos e pontos de melhoria."
          },
          {
            "id": "metas-heranca",
            "label": "Quais metas específicas você estabelecerá para consolidar os conceitos de herança?",
            "placeholder": "Defina objetivos mensuráveis para aplicar herança com segurança."
          },
          {
            "id": "apoios-necessarios",
            "label": "De que apoios (mentor, pares, materiais) você precisa para cumprir o plano?",
            "placeholder": "Indique recursos, pessoas ou rotinas que ajudarão na execução."
          }
        ]
      }
    },
    {
      "type": "callout",
      "variant": "info",
      "title": "Pergunta norteadora",
      "content": [
        {
          "type": "paragraph",
          "text": "Qual comportamento realmente precisa ser herdado? Há riscos de dependências rígidas se a hierarquia crescer demais?"
        }
      ]
    },
    {
      "type": "callout",
      "variant": "warning",
      "title": "Atenção aos erros recorrentes",
      "content": [
        {
          "type": "list",
          "items": [
            "Ignorar validações ao mover atributos para a superclasse, permitindo estados inválidos.",
            "Esquecer de marcar métodos com `@Override`, mascarando comportamentos antigos.",
            "Chamar `super()` após inicializações específicas e gerar `NullPointerException`.",
            "Não atualizar testes para cobrir regras diferenciadas de `Analista` e `Estagiario`.",
            "Duplicar lógica de cálculo salarial nas subclasses em vez de reutilizar `super`."
          ]
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "Quando usar herança",
      "content": [
        {
          "type": "paragraph",
          "text": "Herança favorece reutilização de código quando as classes compartilham identidade conceitual. Evite usar apenas para reaproveitar trechos isolados."
        },
        {
          "component": "OrderedList",
          "props": {
            "items": [
              {
                "title": "Compartilhe contrato",
                "text": "Superclasse define métodos que todas as subclasses devem fornecer."
              },
              {
                "title": "Especialize comportamento",
                "text": "Subclasses sobrescrevem métodos para adicionar regras específicas."
              },
              {
                "title": "Evite herança acidental",
                "text": "Se não houver relação `é-um`, prefira composição."
              }
            ]
          }
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "Composição ou herança?",
      "content": [
        {
          "type": "paragraph",
          "text": "Segundo Barnes & Kölling (2023), a composição favorece mudanças localizadas ao permitir que objetos deleguem responsabilidades a outros componentes em vez de depender de cadeias profundas de herança."
        },
        {
          "type": "paragraph",
          "text": "Deitel (2023) recomenda avaliar se existe uma clara relação `é-um`; caso contrário, prefira montar o comportamento com objetos membros (`tem-um`)."
        },
        {
          "component": "OrderedList",
          "props": {
            "items": [
              {
                "title": "Use herança quando...",
                "text": "A subclasse precisa estender uma abstração estável e reutilizar implementações existentes."
              },
              {
                "title": "Use composição quando...",
                "text": "O comportamento varia em tempo de execução ou pode ser combinado dinamicamente com outras funções."
              },
              {
                "title": "Critério de decisão",
                "text": "Faça um quadro de responsabilidades e identifique se a especialização altera a identidade conceitual do objeto."
              }
            ]
          }
        },
        {
          "type": "code",
          "language": "text",
          "code": "Comparação rápida\n+------------------+----------------------------+\n| Herança           | Compartilha estrutura fixa |\n| Composição        | Combina componentes flexíveis |\n+------------------+----------------------------+"
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "Hierarquia simples vs. múltipla",
      "content": [
        {
          "type": "paragraph",
          "text": "Barnes & Kölling (2023) destacam que o Java adota herança simples: cada classe concreta só pode estender uma superclasse direta, formando uma árvore clara de responsabilidades."
        },
        {
          "type": "paragraph",
          "text": "Deitel (2023) reforça que a linguagem compensa a ausência de herança múltipla com interfaces, permitindo que uma classe implemente diversos contratos sem herdar implementação duplicada."
        },
        {
          "type": "list",
          "items": [
            "Herança simples → facilita rastrear origem de atributos e comportamentos.",
            "Interfaces → oferecem múltiplos pontos de extensão via métodos abstratos.",
            "Combinação → estenda uma classe base e implemente quantas interfaces forem necessárias."
          ]
        },
        {
          "type": "code",
          "language": "text",
          "code": "Funcionario\n├── Analista (extends Funcionario, implements Avaliavel)\n└── Estagiario (extends Funcionario, implements Treinavel, Avaliavel)"
        }
      ]
    },
    {
      "type": "classDesigner",
      "title": "Mapa da hierarquia `Funcionario`",
      "summary": "Revise atributos, contratos e responsabilidades antes de propor variações em aula.",
      "classes": [
        {
          "id": "funcionario",
          "name": "Funcionario",
          "type": "class",
          "summary": "Superclasse que concentra estado comum e validações obrigatórias.",
          "attributes": [
            {
              "id": "funcionario-nome",
              "signature": "protected final String nome",
              "visibility": "protected",
              "note": "Compartilhado com subclasses mantendo encapsulamento controlado."
            },
            {
              "id": "funcionario-salario-base",
              "signature": "protected final double salarioBase",
              "visibility": "protected",
              "note": "Base para todos os cálculos específicos."
            }
          ],
          "methods": [
            {
              "id": "funcionario-construtor",
              "signature": "public Funcionario(String nome, double salarioBase)",
              "visibility": "public",
              "note": "Valida entradas para garantir invariantes da hierarquia."
            },
            {
              "id": "funcionario-get-nome",
              "signature": "public String getNome()",
              "visibility": "public"
            },
            {
              "id": "funcionario-calcular-salario",
              "signature": "public double calcularSalario()",
              "visibility": "public",
              "note": "Retorna o valor base reutilizado por subclasses."
            }
          ],
          "responsibilities": [
            "Centralizar dados e validações compartilhados pelos colaboradores.",
            "Oferecer ponto de extensão para cálculos especializados."
          ]
        },
        {
          "id": "analista",
          "name": "Analista",
          "type": "class",
          "summary": "Especializa o salário com bônus de projeto ao implementar contratos de avaliação.",
          "attributes": [
            {
              "id": "analista-bonus",
              "signature": "private final double bonusProjeto",
              "visibility": "private",
              "note": "Deve ser validado para manter valores não negativos."
            }
          ],
          "methods": [
            {
              "id": "analista-construtor",
              "signature": "public Analista(String nome, double salarioBase, double bonusProjeto)",
              "visibility": "public",
              "note": "Encadeia validações da superclasse e acrescenta a do bônus."
            },
            {
              "id": "analista-calcular-salario",
              "signature": "@Override public double calcularSalario()",
              "visibility": "public",
              "note": "Soma o bônus ao resultado de `super.calcularSalario()`."
            }
          ],
          "responsibilities": [
            "Aplicar regras adicionais de remuneração para analistas.",
            "Atender aos critérios definidos pelo contrato `Avaliavel`."
          ]
        },
        {
          "id": "estagiario",
          "name": "Estagiario",
          "type": "class",
          "summary": "Subclasse que calcula remuneração proporcional à carga horária.",
          "attributes": [
            {
              "id": "estagiario-horas",
              "signature": "private final int horasSemana",
              "visibility": "private",
              "note": "Aceita valores entre 1 e 40 para preservar regras trabalhistas."
            }
          ],
          "methods": [
            {
              "id": "estagiario-construtor",
              "signature": "public Estagiario(String nome, double salarioBase, int horasSemana)",
              "visibility": "public",
              "note": "Invoca `super(...)` antes de validar a jornada semanal."
            },
            {
              "id": "estagiario-calcular-salario",
              "signature": "@Override public double calcularSalario()",
              "visibility": "public",
              "note": "Aplica a proporção de horas sobre o salário base herdado."
            }
          ],
          "responsibilities": [
            "Adaptar o cálculo salarial ao regime parcial do estagiário.",
            "Cumprir contratos `Treinavel` e `Avaliavel` definidos pela turma."
          ]
        },
        {
          "id": "avaliavel",
          "name": "Avaliavel",
          "type": "interface",
          "stereotype": "interface",
          "summary": "Contrato que orienta como mensurar desempenho das funções técnicas.",
          "methods": [
            {
              "id": "avaliavel-medir",
              "signature": "double avaliar()",
              "note": "Sugestão inicial — ajuste métricas com a turma ao evoluir o exercício."
            }
          ],
          "responsibilities": ["Definir indicadores de avaliação alinhados à política da empresa."]
        },
        {
          "id": "treinavel",
          "name": "Treinavel",
          "type": "interface",
          "stereotype": "interface",
          "summary": "Contrato usado para planejar ações de capacitação.",
          "methods": [
            {
              "id": "treinavel-participar",
              "signature": "void participarTreinamento()",
              "note": "Permite mapear rituais de aprendizagem contínua."
            }
          ],
          "responsibilities": [
            "Registrar obrigações de desenvolvimento profissional para estagiários."
          ]
        }
      ],
      "relationships": [
        {
          "id": "analista-herda-funcionario",
          "from": "analista",
          "to": "funcionario",
          "type": "inheritance",
          "description": "Analista reutiliza as validações e expande o cálculo salarial."
        },
        {
          "id": "estagiario-herda-funcionario",
          "from": "estagiario",
          "to": "funcionario",
          "type": "inheritance",
          "description": "Estagiario mantém invariantes da superclasse e ajusta remuneração."
        }
      ],
      "legend": [
        {
          "id": "heranca",
          "label": "Seta cheia",
          "description": "Indica relação de herança (`extends`). Acrescente realizações pontilhadas para interfaces se necessário."
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "Modificadores de acesso na herança",
      "content": [
        {
          "type": "paragraph",
          "text": "Os autores Deitel (2023) e Barnes & Kölling (2023) convergem ao orientar o uso criterioso de `public`, `protected` e `private` para proteger invariantes ao estender classes."
        },
        {
          "component": "OrderedList",
          "props": {
            "items": [
              {
                "title": "public",
                "text": "Visível a todas as classes. Use para comportamentos que compõem a API estável da superclasse."
              },
              {
                "title": "protected",
                "text": "Visível a subclasses e ao pacote. Ideal para expor ganchos de extensão sem quebrar encapsulamento."
              },
              {
                "title": "private",
                "text": "Restrito à classe que declara. Preserve regras internas delegando acesso via getters/setters controlados."
              }
            ]
          }
        },
        {
          "type": "paragraph",
          "text": "Combine modificadores com classes utilitárias no mesmo pacote quando precisar compartilhar lógica de suporte sem abrir toda a API."
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "Uso de `super` e ciclos de vida",
      "content": [
        {
          "type": "paragraph",
          "text": "Deitel (2023) lembra que construtores de subclasses devem invocar `super()` como primeira instrução para garantir inicialização consistente do estado herdado."
        },
        {
          "type": "paragraph",
          "text": "Ao sobrescrever métodos, Barnes & Kölling (2023) sugerem chamar `super.metodo()` quando a superclasse já fornece parte da lógica e apenas uma etapa adicional precisa ser acrescentada."
        },
        {
          "type": "list",
          "items": [
            "Use `super` para acessar implementações originais que permanecem válidas.",
            "Evite duplicar validações herdadas — delegue ao construtor da superclasse.",
            "Documente efeitos colaterais herdados para orientar futuras subclasses."
          ]
        }
      ]
    },
    {
      "type": "contentBlock",
      "title": "Exemplo comentado de herança em Java",
      "content": [
        {
          "type": "paragraph",
          "text": "Note como a superclasse concentra validações e o estado compartilhado, enquanto as subclasses apenas especializam o cálculo salarial."
        },
        {
          "type": "code",
          "language": "java",
          "code": "public class Funcionario {\n    // Use 'protected' para expor somente o necessário às subclasses mantendo encapsulamento.\n    protected final String nome;\n    protected final double salarioBase;\n\n    public Funcionario(String nome, double salarioBase) {\n        // Valide entradas no construtor para garantir objetos sempre consistentes.\n        if (nome == null || nome.isBlank()) {\n            throw new IllegalArgumentException(\"Nome não pode ser vazio\");\n        }\n        if (salarioBase < 0) {\n            throw new IllegalArgumentException(\"Salário base deve ser não negativo\");\n        }\n        this.nome = nome;\n        this.salarioBase = salarioBase;\n    }\n\n    public String getNome() {\n        return nome;\n    }\n\n    public double calcularSalario() {\n        return salarioBase;\n    }\n}\n\npublic class Analista extends Funcionario {\n    private final double bonusProjeto;\n\n    public Analista(String nome, double salarioBase, double bonusProjeto) {\n        super(nome, salarioBase); // Delegue ao construtor da superclasse sempre que precisar reutilizar validações comuns.\n        if (bonusProjeto < 0) {\n            throw new IllegalArgumentException(\"Bônus deve ser não negativo\");\n        }\n        this.bonusProjeto = bonusProjeto;\n    }\n\n    @Override\n    public double calcularSalario() {\n        return super.calcularSalario() + bonusProjeto;\n    }\n}\n\npublic class Estagiario extends Funcionario {\n    private final int horasSemana;\n\n    public Estagiario(String nome, double salarioBase, int horasSemana) {\n        super(nome, salarioBase); // Chame 'super()' primeiro para garantir que o estado herdado seja inicializado corretamente.\n        if (horasSemana <= 0 || horasSemana > 40) {\n            throw new IllegalArgumentException(\"Horas semanais devem estar entre 1 e 40\");\n        }\n        this.horasSemana = horasSemana;\n    }\n\n    @Override\n    public double calcularSalario() {\n        return super.calcularSalario() * horasSemana / 40.0;\n    }\n}\n\npublic class FolhaPagamento {\n    public static void main(String[] args) {\n        // Rotina rápida de teste para demonstrar polimorfismo e verificar sobrescritas.\n        Funcionario ana = new Analista(\"Ana\", 6000, 1200);\n        Funcionario joao = new Estagiario(\"João\", 2000, 30);\n\n        System.out.printf(\"%s recebe R$ %.2f\\n\", ana.getNome(), ana.calcularSalario());\n        System.out.printf(\"%s recebe R$ %.2f\\n\", joao.getNome(), joao.calcularSalario());\n    }\n}"
        }
      ]
    },
    {
      "type": "component",
      "component": "Md3CodeSample",
      "props": {
        "title": "Rotina completa com `super` e polimorfismo",
        "summary": "Construtores chamam <code>super(...)</code> logo no início, métodos sobrescritos reutilizam lógica comum e a rotina de teste confirma o comportamento especializado.",
        "language": "java",
        "code": "import java.util.List;\n\npublic class Funcionario {\n    // Construtor centraliza validações compartilhadas e garante invariantes.\n    protected final String nome;\n    protected final double salarioBase;\n\n    public Funcionario(String nome, double salarioBase) {\n        if (nome == null || nome.isBlank()) {\n            throw new IllegalArgumentException(\"Nome não pode ser vazio\");\n        }\n        if (salarioBase < 0) {\n            throw new IllegalArgumentException(\"Salário base deve ser não negativo\");\n        }\n        this.nome = nome.trim();\n        this.salarioBase = salarioBase;\n    }\n\n    public String getNome() {\n        return nome;\n    }\n\n    public double calcularSalario() {\n        // Subclasses podem somar componentes adicionais sobre este valor.\n        return salarioBase;\n    }\n}\n\npublic class Analista extends Funcionario {\n    private final double bonusProjeto;\n\n    public Analista(String nome, double salarioBase, double bonusProjeto) {\n        super(nome, salarioBase); // Reaproveita as validações de estado da superclasse.\n        if (bonusProjeto < 0) {\n            throw new IllegalArgumentException(\"Bônus deve ser não negativo\");\n        }\n        this.bonusProjeto = bonusProjeto;\n    }\n\n    @Override\n    public double calcularSalario() {\n        double salarioComBonus = super.calcularSalario() + bonusProjeto;\n        // Documente a regra para facilitar futuras extensões.\n        return salarioComBonus;\n    }\n}\n\npublic class Estagiario extends Funcionario {\n    private final int horasSemana;\n\n    public Estagiario(String nome, double salarioBase, int horasSemana) {\n        super(nome, salarioBase); // Sempre invoque super(...) como primeira linha do construtor.\n        if (horasSemana <= 0 || horasSemana > 40) {\n            throw new IllegalArgumentException(\"Horas semanais devem estar entre 1 e 40\");\n        }\n        this.horasSemana = horasSemana;\n    }\n\n    @Override\n    public double calcularSalario() {\n        double proporcional = super.calcularSalario() * horasSemana / 40.0;\n        return proporcional;\n    }\n}\n\npublic final class FolhaPagamento {\n    private FolhaPagamento() {\n        // Evite instanciar utilitários - mantenha apenas membros estáticos.\n    }\n\n    public static void main(String[] args) {\n        Funcionario analista = new Analista(\"Ana\", 6000, 1200);\n        Funcionario estagiario = new Estagiario(\"João\", 2000, 30);\n\n        List<Funcionario> equipe = List.of(analista, estagiario);\n        for (Funcionario funcionario : equipe) {\n            System.out.printf(\"%s recebe R$ %.2f%n\", funcionario.getNome(), funcionario.calcularSalario());\n        }\n    }\n}",
        "highlights": [
          "Comentários estratégicos orientam futuras refatorações e reforçam as motivações das escolhas de design.",
          "`super(...)` aparece na primeira linha dos construtores, garantindo inicialização do estado herdado.",
          "A rotina `main` percorre uma lista polimórfica demonstrando a diferença de cada sobrescrita."
        ]
      }
    },
    {
      "type": "stepper",
      "title": "Exercício guiado: refatoração da hierarquia `Funcionario`",
      "steps": [
        {
          "title": "Mapear atributos e validações comuns",
          "description": "Tempo estimado: 10 min | Perguntas: Quais campos aparecem em todas as classes atuais? Existem validações duplicadas? | Critérios de sucesso: checklist de atributos compartilhados e validações acordadas com a dupla."
        },
        {
          "title": "Extrair a superclasse `Funcionario`",
          "description": "Tempo estimado: 15 min | Perguntas: Que construtor garante estado consistente? Quais métodos permanecem genéricos? | Critérios de sucesso: superclasse compilando com testes existentes passando sem alterações."
        },
        {
          "title": "Criar `Analista` e `Estagiario`",
          "description": "Tempo estimado: 15 min | Perguntas: Que dados adicionais cada perfil exige? Há comportamento exclusivo? | Critérios de sucesso: subclasses instanciadas sem duplicação de código e cobrindo os cenários discutidos."
        },
        {
          "title": "Sobrescrever métodos críticos",
          "description": "Tempo estimado: 10 min | Perguntas: O cálculo salarial respeita regras de negócio? Precisamos chamar `super`? | Critérios de sucesso: métodos sobrescritos com testes exibindo resultados distintos por perfil."
        },
        {
          "title": "Executar e revisar testes",
          "description": "Tempo estimado: 10 min | Perguntas: Todos os cenários foram cobertos? Há casos-limite pendentes? | Critérios de sucesso: suíte de testes passando e registro dos aprendizados/ajustes no repositório da turma."
        }
      ]
    },
    {
      "type": "checklist",
      "title": "Checklist guiado de refatoração",
      "description": "Percorra cada etapa antes de finalizar a migração para a hierarquia `Funcionario`:",
      "items": [
        "Concentrar atributos e validações comuns na superclasse antes de mover comportamento especializado.",
        "Garantir que todos os construtores de subclasses chamem `super(...)` como primeira instrução.",
        "Adicionar `@Override` nas operações sobrescritas e validar diferenças funcionais em `Analista` e `Estagiario`.",
        "Executar a rotina `main` ou a suíte de testes para confirmar o polimorfismo e registrar aprendizados."
      ]
    },
    {
      "type": "component",
      "component": "Md3Flowchart",
      "props": {
        "title": "Fluxo de construção da hierarquia",
        "nodes": [
          {
            "id": "start",
            "type": "start",
            "title": "Identificar características comuns"
          },
          {
            "id": "super",
            "type": "process",
            "title": "Criar superclasse com atributos e métodos compartilhados"
          },
          {
            "id": "decisao",
            "type": "decision",
            "title": "Existe comportamento específico?",
            "branches": [
              {
                "id": "sim",
                "label": "Sim",
                "target": "subclasse"
              },
              {
                "id": "nao",
                "label": "Não",
                "target": "usar"
              }
            ]
          },
          {
            "id": "subclasse",
            "type": "process",
            "title": "Implementar subclasse e sobrescrever métodos"
          },
          {
            "id": "usar",
            "type": "output",
            "title": "Instanciar objetos e testar polimorfismo"
          },
          {
            "id": "end",
            "type": "end",
            "title": "Hierarquia validada"
          }
        ],
        "connections": [
          {
            "from": "start",
            "to": "super"
          },
          {
            "from": "super",
            "to": "decisao"
          },
          {
            "from": "decisao",
            "to": "subclasse",
            "label": "Sim"
          },
          {
            "from": "decisao",
            "to": "usar",
            "label": "Não"
          },
          {
            "from": "subclasse",
            "to": "usar"
          },
          {
            "from": "usar",
            "to": "end"
          }
        ]
      }
    },
    {
      "type": "component",
      "component": "Md3CodeSample",
      "props": {
        "title": "Record para objeto de valor",
        "summary": "Encapsula o campo com validação no construtor compacto, preservando invariantes e evitando exposição acidental.",
        "language": "java",
        "code": "import java.util.Objects;\nimport java.util.regex.Pattern;\n\npublic record EmailAddress(String value) {\n    private static final Pattern SIMPLE_PATTERN = Pattern.compile(\"^[\\\\w.+-]+@[\\\\w.-]+\\\\.[A-Za-z]{2,}$\");\n\n    public EmailAddress {\n        Objects.requireNonNull(value, \"E-mail é obrigatório\");\n        String normalized = value.trim().toLowerCase();\n        if (normalized.isBlank() || !SIMPLE_PATTERN.matcher(normalized).matches()) {\n            throw new IllegalArgumentException(\"Formato de e-mail inválido\");\n        }\n        value = normalized; // Canonical constructor do record atribui o campo após sanitização.\n    }\n\n    public String domain() {\n        return value.substring(value.indexOf('@') + 1);\n    }\n}\n\nfinal class LegacyEmailAddress {\n    private final String value;\n\n    LegacyEmailAddress(String value) {\n        Objects.requireNonNull(value, \"E-mail é obrigatório\");\n        String normalized = value.trim().toLowerCase();\n        if (normalized.isBlank() || !EmailAddress.SIMPLE_PATTERN.matcher(normalized).matches()) {\n            throw new IllegalArgumentException(\"Formato de e-mail inválido\");\n        }\n        this.value = normalized;\n    }\n\n    String domain() {\n        return value.substring(value.indexOf('@') + 1);\n    }\n\n    String value() {\n        return value;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof LegacyEmailAddress other)) return false;\n        return value.equals(other.value);\n    }\n\n    @Override\n    public int hashCode() {\n        return value.hashCode();\n    }\n}\n",
        "highlights": [
          "O record encapsula o campo `value` sem gerar getters extras além dos implícitos, reduzindo a superfície exposta.",
          "O construtor compacto garante invariantes como formato e normalização antes de concluir a criação do objeto.",
          "Recorra a uma classe tradicional quando precisar de herança, mutabilidade ou controle fino sobre métodos auxiliares."
        ]
      }
    },
    {
      "type": "component",
      "component": "CodeSubmission",
      "props": {
        "title": "Entregue sua hierarquia de funcionários",
        "prompt": "Implemente a hierarquia `Funcionario`, `Analista` e `Estagiario` garantindo reutilização de código e validações consistentes. Cada subclasse deve especializar o cálculo salarial respeitando as regras discutidas em aula.",
        "language": "java",
        "boilerplate": "public class Funcionario {\n    private final String nome;\n    private final double salarioBase;\n\n    public Funcionario(String nome, double salarioBase) {\n        // TODO: validar entradas e inicializar campos\n    }\n\n    public String getNome() {\n        // TODO: retornar nome validado\n        return null;\n    }\n\n    public double getSalarioBase() {\n        // TODO: retornar salário base\n        return 0.0;\n    }\n\n    public double calcularSalario() {\n        // TODO: calcular valor base reutilizado pelas subclasses\n        return 0.0;\n    }\n}\n\nclass Analista extends Funcionario {\n    private final double bonusProjeto;\n\n    public Analista(String nome, double salarioBase, double bonusProjeto) {\n        super(nome, salarioBase);\n        // TODO: validar bônus de projeto e atribuir ao campo\n        this.bonusProjeto = 0.0;\n    }\n\n    @Override\n    public double calcularSalario() {\n        // TODO: somar o bônus ao resultado da superclasse\n        return 0.0;\n    }\n}\n\nclass Estagiario extends Funcionario {\n    private final int horasSemana;\n\n    public Estagiario(String nome, double salarioBase, int horasSemana) {\n        super(nome, salarioBase);\n        // TODO: validar horas semanais (1 a 40) e atribuir\n        this.horasSemana = 0;\n    }\n\n    @Override\n    public double calcularSalario() {\n        // TODO: aplicar proporcionalidade ao salário base\n        return 0.0;\n    }\n}\n",
        "tests": [
          {
            "name": "Analista recebe bônus integral",
            "input": "Analista ana = new Analista(\"Ana\", 4000.0, 500.0);\nSystem.out.println(ana.calcularSalario());",
            "expectedOutput": "4500.0"
          },
          {
            "name": "Estagiário recebe proporcional de 20h",
            "input": "Estagiario joao = new Estagiario(\"João\", 2000.0, 20);\nSystem.out.println(joao.calcularSalario());",
            "expectedOutput": "1000.0"
          }
        ],
        "tips": [
          "Use a anotação @Override para deixar claro quais métodos estão sendo sobrescritos.",
          "Aproveite super(...) e super.calcularSalario() para evitar duplicar validações e cálculos compartilhados."
        ]
      }
    },
    {
      "type": "contentBlock",
      "title": "Tarefa assíncrona: consolidar o plano pós-AV1",
      "content": [
        {
          "type": "paragraph",
          "text": "Converta os insights da aula em compromissos mensuráveis e compartilhe com a dupla de acompanhamento."
        },
        {
          "component": "OrderedList",
          "props": {
            "items": [
              {
                "title": "Metas prioritárias",
                "text": "Mapeie ao menos duas habilidades da AV1 que precisam de reforço, vinculando-as a indicadores concretos (ex.: testes que falharam, dúvidas recorrentes)."
              },
              {
                "title": "Entregáveis",
                "text": "Atualize o repositório da disciplina com uma versão refinada da hierarquia `Funcionario` e registre no README o racional das mudanças."
              },
              {
                "title": "Prazo",
                "text": "Submeta as evidências até sexta-feira, 23h59, garantindo tempo para feedback antes da aula 06."
              },
              {
                "title": "Critérios de qualidade",
                "text": "Mantenha cobertura de testes para os cenários críticos da AV1, documente métricas de complexidade se houver ajustes significativos e descreva implicações no plano de ação individual."
              }
            ]
          }
        },
        {
          "type": "paragraph",
          "text": "Os artefatos entregues alimentam o plano de ação individual listado nos outcomes, orientando mentorias e intervenções personalizadas nas próximas sprints."
        }
      ]
    }
  ],
  "metadata": {
    "status": "in-review",
    "updatedAt": "2025-10-03T18:39:18.000Z",
    "owners": ["Prof. Tiago Sombra"],
    "sources": ["Relatório AV1 2025.2", "Plano de aula LPOO – módulo 2"]
  }
}
